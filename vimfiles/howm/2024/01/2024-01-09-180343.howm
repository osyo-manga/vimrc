= [ruby, core ML] 2024年に気になった bugs.ruby





源泉徴収票➁
源泉徴収票②





published_at: 2024-11-15


tenant_group_spec
済
## [[Feature #20326] Add an `undefined` for use as a default argument.](https://bugs.ruby-lang.org/issues/20326)
## [[Feature #20164] Add Exception#deconstruct_keys](https://bugs.ruby-lang.org/issues/20164)
## [[Bug # 20253] `Proc.dup` and `Proc#clone` don't preserve finalizers](https://bugs.ruby-lang.org/issues/20253)
## [[Feature #20318] Pattern matching `case ... in` support for triple-dot arguments](https://bugs.ruby-lang.org/issues/20318)
## [[Feature #20564] Switch default parser to Prism](https://bugs.ruby-lang.org/issues/20564)
## [[Feature #20484] A new pragma for eager resolution of classes referenced in rescue clauses.](https://bugs.ruby-lang.org/issues/20484)
## [[Feature #20349] Pattern Matching - Expose local variable captures](https://bugs.ruby-lang.org/issues/20349)
## [[Feature #20160] rescue keyword for case expressions](https://bugs.ruby-lang.org/issues/20160)
## [[Misc #20509] Document importance of #to_ary and #to_hash for Array#== and Hash#==](https://bugs.ruby-lang.org/issues/20509)
## [[Feature #19370] Anonymous parameters for blocks?](https://bugs.ruby-lang.org/issues/19370)
## [[Feature #20498] Negated method calls](https://bugs.ruby-lang.org/issues/20498)
## [[Feature #20882] Provide Boolean(...)](https://bugs.ruby-lang.org/issues/20882)
## [[Bug #20573] Warning.warn shouldn't be called for disabled warnings](https://bugs.ruby-lang.org/issues/20573)
## [[Bug #2044] Kernel#loop: returning the "result" value of StopIteration doesn't work when raised directly](https://bugs.ruby-lang.org/issues/20444)
## [[Feature #20703] Alias StringIO#string to StringIO#to_s](https://bugs.ruby-lang.org/issues/20703)
## [[Bug #20643] Ruby 3.2 behavior change for protected and private methods when yield self](https://bugs.ruby-lang.org/issues/20643)
## [[Misc #20575] Syntax Moratorium til 3.4](https://bugs.ruby-lang.org/issues/20575)
## [20594][Misc #20746] Request to migrate the json gem from flori/json repository to ruby/json](https://bugs.ruby-lang.org/issues/20746)
## [[Bug #20880] Hash allows array-type key duplicates](https://bugs.ruby-lang.org/issues/20880)
## [[Bug #20505] Reassigning the block argument in method body keeps old block when calling super with implicit arguments](https://bugs.ruby-lang.org/issues/20505)



## [[Bug #20858] multiple parallel assignments are inconsistent](https://bugs.ruby-lang.org/issues/20858)


## [[Feature #20770] A *new* pipe operator proposal](https://bugs.ruby-lang.org/issues/20770)
    * [[Feature #20580] Pipe Operator accepting lambda](https://bugs.ruby-lang.org/issues/20580)



------

## [[Bug #20880] Hash allows array-type key duplicates](https://bugs.ruby-lang.org/issues/20880)
## [[Feature #20811] `warning: in a**b, b may be too big` is really helpful?](https://bugs.ruby-lang.org/issues/20811)
## [[Feature #20818] Allow passing a block to Hash#store (to update current value)](https://bugs.ruby-lang.org/issues/20818)
## [[Feature #6648] Provide a standard API for retrieving all command-line flags passed to Ruby](https://bugs.ruby-lang.org/issues/6648)
## [[Feature #20770] A *new* pipe operator proposal](https://bugs.ruby-lang.org/issues/20770)
    * [[Feature #20580] Pipe Operator accepting lambda](https://bugs.ruby-lang.org/issues/20580)
## [[Feature #20742] Trying to assign to a variable in statement modifier should emit a warning](https://bugs.ruby-lang.org/issues/20742)
## [[Feature #13820] Add a nil coalescing operator](https://bugs.ruby-lang.org/issues/13820)
## [[Feature #20676] Pathnames aren't Comparable](https://bugs.ruby-lang.org/issues/20676)
## [[Bug #20675] Parse error with required kwargs and omitted parens](https://bugs.ruby-lang.org/issues/20675)
## [[Feature #20657] Allow Enumerable#map(&:method) and #each accept additional parameters for method](https://bugs.ruby-lang.org/issues/20657)
## [[Feature #18368] Range#step semantics for non-Numeric ranges](https://bugs.ruby-lang.org/issues/18368)
## [[Feature #20625] Object#chain_of](https://bugs.ruby-lang.org/issues/20625)
## [[Feature #20508] Explicit access to *, **, &, and ...](https://bugs.ruby-lang.org/issues/20508)
## [[Bug #20482] nil variables in a guard clause of a standalone => or in expression](https://bugs.ruby-lang.org/issues/20482)
## [[Bug #20433] Hash.inspect for some hash returns syntax invalid representation](https://bugs.ruby-lang.org/issues/20433)
## [[Feature #15554] warn/error passing a block to a method which never use a block](https://bugs.ruby-lang.org/issues/15554)
## [[Bug #20411] Kenrel.autoload? behaviour](https://bugs.ruby-lang.org/issues/20411)
## [[Bug #20392] Delegate super calls with a block](https://bugs.ruby-lang.org/issues/20392)
## [[Feature #20211] Consider re-adding 3.2-style support of Anonymous Args/Blocks](https://bugs.ruby-lang.org/issues/20211)
## [[Feature #20202] Memoized endless method definitions](https://bugs.ruby-lang.org/issues/20202)
## [[Bug #20314] Simultaneous Timeout expires may raise an exception after the block](https://bugs.ruby-lang.org/issues/20314)
## [[Feature #20196] Proposal: Binary data literal](https://bugs.ruby-lang.org/issues/20196)
## [[Feature #20298] Introduce `Time()` type-cast / constructor.](https://bugs.ruby-lang.org/issues/20298)
## [[Bug #20278] syntax error, unexpected local variable or method, expecting ')' (SyntaxError) - but I think it should report that a ',' is missing, or alternatively, that suggesting ')' is the most likely cause but not always (e. g. reword it a bit)](https://bugs.ruby-lang.org/issues/20278)
## [[Feature #20205] Enable `frozen_string_literal` by default](https://bugs.ruby-lang.org/issues/20205)
## [[Bug #20188] `Module#const_source_location` returns wrong information when real constant was defined but autoload is still ongoing](https://bugs.ruby-lang.org/issues/20188)
## [[Bug #20043] `defined?` checks for method existence but only sometimes](https://bugs.ruby-lang.org/issues/20043)
## [[Feature #20080] Introduce #bounds method on Range](https://bugs.ruby-lang.org/issues/20080)


## [[Feature #15381] Let double splat call `to_h` implicitly](https://bugs.ruby-lang.org/issues/15381)
## [[Feature #18242] Parser makes multiple assignment sad in confusing way](https://bugs.ruby-lang.org/issues/18242)
## [[Feature #20793] I propose allowing multiple arguments to be passed to the .is_a? Method imply "OR" semantics:](https://bugs.ruby-lang.org/issues/20793)
## [[Feature #20756] Introduce Boolean class](https://bugs.ruby-lang.org/issues/20756)
## [[Misc #20746] Request to migrate the json gem from flori/json repository to ruby/json](https://bugs.ruby-lang.org/issues/20746)
## [[Feature #20669] Add Marshal::MarshalError class to differentiate ArgumentErrors](https://bugs.ruby-lang.org/issues/20669)
## [[Feature #20664] Add `before` and `until` options to Enumerator.produce](https://bugs.ruby-lang.org/issues/20664)
## [[Bug #20647] Invalid return in class/module body from within singleton class](https://bugs.ruby-lang.org/issues/20647)
## [[Bug #20620] singleton_method undefined for module using "extend self"](https://bugs.ruby-lang.org/issues/20620)
## [[Bug #20593] `Kernel#format` emits a `too many arguments for format string` warning when called with a single hash and no key is used](https://bugs.ruby-lang.org/issues/20593)
## [[Bug #20586] Some filesystem calls in dir.c are missing error handling and can return incorrect results if interrupted](https://bugs.ruby-lang.org/issues/20586)
## [[Bug #20468] Segfault on safe navigation in for target](https://bugs.ruby-lang.org/issues/20468)
## [[Bug #20440] `super` from child class duplicating a keyword argument as a positional Hash](https://bugs.ruby-lang.org/issues/20440)
## [[Feature #20428] Ability to reference current class/module in lexical scope](https://bugs.ruby-lang.org/issues/20428)
## [[Bug #20307] `Hash#update` from compare_by_identity hash can have unfrozen string keys](https://bugs.ruby-lang.org/issues/20307)
## [[Bug #20342] Top level `public`, `private` and `ruby2_keywords` do not work in wrapped load](https://bugs.ruby-lang.org/issues/20342)
## [[Bug #20319] Singleton class is being frozen lazily in some cases](https://bugs.ruby-lang.org/issues/20319)


## [[Bug #20701] Hash argument passed as keyword splat can be mutated inside method](https://bugs.ruby-lang.org/issues/20701)
## [[Bug #18622] const_get still looks in Object, while lexical constant lookup no longer does](https://bugs.ruby-lang.org/issues/18622)
## [[Feature #20565] Relax formal argument at label](https://bugs.ruby-lang.org/issues/20565)
## [[Feature #20396] ObjectSpace.dump_all(string_value: false): skip dumping the String contents](https://bugs.ruby-lang.org/issues/20396)

## [[Bug #20857] Ruby 3.4 seems to have backwards compatibility issues more than its predecessors](https://bugs.ruby-lang.org/issues/20857)


---



https://bugs.ruby-lang.org/issues/20763
https://github.com/rails/rails/pull/53055
https://bugs.ruby-lang.org/issues/20761
https://bugs.ruby-lang.org/issues/20766
https://bugs.ruby-lang.org/issues/20770



callable-source






```ruby
pp "\u{3036}" #=> "〶"
pp Float("\u{3036}".encode("utf-16be")) #=> 6.0
```


@[card](https://zenn.dev/mamayukawaii/articles/20240313200648)



## [[Feature #20925] Allow boolean operators at beginning of line to continue previous line](https://bugs.ruby-lang.org/issues/20925)

* 以下のように `||` や `&&` などを行頭でもかけるように許容する提案

```ruby
condition1
|| condition2

condition1
&& condition2

condition1
or condition2

condition1
and condition2
```

* これめっちゃわかるんですよねえ、例えば `if` の条件式で利用すると以下のように縦にわかりやすくかけます

```ruby
if condition1
&& condition2
&& condition3

end
```

* あと行頭に `||` `&&` に書いてあるほうがパッと見のコードの意図が読み取りやすいのはありますねえ

```ruby
# こっちは末尾まで見ないとこれが複数の条件式なのかどうかわからない
request.secret_key_base.present? &&
  request.encrypted_signed_cookie_salt.present? &&
  request.encrypted_cookie_salt.present? &&
  request.use_authenticated_cookie_encryption

# こっちは行頭をみるだけで複数の条件式であることが明確である
request.secret_key_base.present?
  && request.encrypted_signed_cookie_salt.present?
  && request.encrypted_cookie_salt.present?
  && request.use_authenticated_cookie_encryption
```

* あとは次のようなコードの場合に `if` の中身が分かりづらい、みたいな話もありますね
    * https://bugs.ruby-lang.org/issues/20925#note-2

```ruby
# パッと見、どこまでが条件式でどこまでが本体かわかりづらい…
if request.secret_key_base.present? &&
  request.encrypted_signed_cookie_salt.present? &&
  request.encrypted_cookie_salt.present?
  request.encrypted_cookie
end

# こっちだと明らかにわかりやすい
if request.secret_key_base.present?
  && request.encrypted_signed_cookie_salt.present?
  && request.encrypted_cookie_salt.present?
  request.encrypted_cookie
end
```

* この提案自体は概ねポジティブで matz も同意していますね
    * https://bugs.ruby-lang.org/issues/20925#note-5
* あとはパーサの実装さえできれば…ってところですかねー
* ちなみにわたしはこういうときは末尾に `\` をつけてごまかすことが多いです

```ruby
# 実質条件式が1行になるのでこれは動作する
if request.secret_key_base.present? \
  && request.encrypted_signed_cookie_salt.present? \
  && request.encrypted_cookie_salt.present?
  request.encrypted_cookie
end
```



## [[Bug #20934] `UnboundMethod#bind_call` may cause "double free or corruption" with Ractor](https://bugs.ruby-lang.org/issues/20934)

* 以下のようにメインと別の `Ractor` 内で `#bind_call` を呼び出すとクラッシュする可能性があるというバグ報告

```ruby
def foo
  10000.times do
    Object.instance_method(:object_id).bind_call(self)
  end
end

Ractor.new { foo }
foo
```

* コメントをみると `Ractor` 固有じゃない可能性もあるみたいですね？
    * https://bugs.ruby-lang.org/issues/20934#note-1



## [[Bug #20943] Constant defined in `Data.define` block](https://bugs.ruby-lang.org/issues/20943)

* 次のように `Data.define` のブロック内で定数を定義すると定義されたクラス内ではなくてトップレベルの定数として定義されます

```ruby
Measure = Data.define(:amount, :unit) do
  NONE = 42
end

pp NONE #=> 42
```

* これを `Measure::NONE` のように定義されることを期待するチケットです
* これなんですが `Data.define` だけではなくて `Struct.new` や `Class.new` も同じ挙動になっています

```ruby
X = Struct.new do
  A = "A"
end
pp A # => "A"

Y = Class.new do
  B = "B"
end
pp B # => "B"
```

* なんとなくそれはそうな気もするけど定義したクラスの配下に定義されてくれる方が直感的ではありますかねえ
* これを回避する手段として動的に定義したクラスを継承するやり方もあります
    * https://bugs.ruby-lang.org/issues/20943#note-2

```ruby
class Measure < Data.define(:amount, :unit)
  NONE = 42
end

pp Measure::NONE #=> 42

# ただし、この場合だと継承リストに匿名クラスが存在することもコメントされている
pp Measure.ancestors
# => [Measure, #<Class:0x000073fc85097db0>, Data, Object, PP::ObjectMixin, Kernel, BasicObject]
```

* 互換性の問題などもあり挙動を変えるのはむずかしそうですねえ
    * https://bugs.ruby-lang.org/issues/20943#note-5


## [[Feature #20429] Emit a performance warning when specially optimized core methods are redefined](https://bugs.ruby-lang.org/issues/20429)

* パフォーマンスに影響があるメソッドを再定義したときに警告を出すようにする提案
* 具体的には以下のメソッドが提示されています
    * `Integer` : `#+, #-, #*, #/, #%, #<, #>, #<=, #>=`
    * `Float` : `#+, #-, #*, #/, #<, #>, #<=, #>=`
    * `String` : `#freeze, #size, #length, #empty?, #+, #succ, #%, #-@`
    * `Array` : `#size, #length, #empty?, #hash`
    * `Hash` : `#size, #length, #empty?, #[], #[]=`
* この対応は承認されて Ruby 3.4 から `-W:performance` が有効な場合に警告がでるようになります

```ruby
Warning[:performance] = true

# warning: Redefining 'String#freeze' disables interpreter and JIT optimizations
class String
  def freeze
    super
  end
end
```



---------------------------------------------------------------------------------------------------------------------------------------------------------



## [[Feature #20914] Constructor Parameter Shortcuts](https://bugs.ruby-lang.org/issues/20914)

* `#initialize` 時に以下のような形でインタンス変数に値を割り当てる提案

```ruby
class User
  def initialize(name, age, email = nil)
    @name = name
    @age = age
    @email = email
  end
end
```

* これを

```ruby
class User
  def initialize(@name, @age, @email = nil) =
end
```

* のように定義できるようにする提案
* 定期的にくる `#initialize` 時にいい感じにインスタンス変数を割り当てたい提案ですねー
* 末尾の `=` は以下のように定義をしていたときの名残みたいですね？

```ruby
# 元々はこう書いていて、ここから短くしたときの名残みたい
def initialize(name, age, email = nil) = (@name, @age, @email = name, age, email)
```

* [Feature #5825: Sweet instance var assignment in the object initializer](https://bugs.ruby-lang.org/issues/5825) でも同じような提案がされており、こちらと重複しているのでこのチケットは close されています


## [[Bug #20911] Array#max doesn't take block if using &:](https://bugs.ruby-lang.org/issues/20911)

* 次のように `#max` にブロックを渡すと数値に変換した値で比較した値が返ってきます

```ruby
pp ["1", "2", "3"].max { |i| i.to_i }
# => "3"
```

* これが `&` 渡しだとうまく動かない、というバグ報告になります

```ruby
# error: no implicit conversion of String into Integer (TypeError)
pp ["1", "2", "3"].max(&:to_i)
```

* これなんですが `#max` のブロックでは2つの引数を受け取り、それを `#<=>` で比較した値を返して並び替える、みたいな挙動になります
* なので以下のように比較するのが正しいコードになります

```ruby
# 正しく比較する場合はこう
pp ["111", "2", "13"].max { |a, b| a.to_i <=> b.to_i }
# => "111"

# i.to_i だけだとそもそもうまく並び替えできない
pp ["3", "2", "1"].max { |i| i.to_i }
# => "1"

pp ["111", "2", "13"].max { |i| i.to_i }
# => "3"
```

* また単純に `to_i` の値だけで並び替えしたい、のであれば `#max_by` が利用できます

```ruby
# ブロックの戻り値で並び替えを行う
pp ["111", "2", "13"].max_by { |i| i.to_i }
# => "111"
```



## [[Feature #20912] Add warning when redefining __id__ as well as object_id](https://bugs.ruby-lang.org/issues/20912)

* 次のように `#object_id` や `#__send__` を再定義すると警告がでます

```ruby
class X
  # warning: redefining `object_id' may cause serious problems
  def object_id = nil

  # warning: redefining `__send__' may cause serious problems
  def __send__ = nil
end
```

* またメソッドを削除したときにも同様に警告がでます

```ruby
class X
  # warning: undefining `object_id' may cause serious problems
  undef_method :object_id

  # warning: undefining `__send__' may cause serious problems
  undef_method :__send__
end
```

* これと同様に `#__id__` でも警告を出すようにし、また `#object_id` では警告がでないようにする提案になります
* これなんですが `#object_id` は `Kenrel` で定義されている一方 `#__send__` と `#__id__` は `BasicObject` で定義されているんですよね

```ruby
class X
end

pp Object.instance_method(:object_id).owner
pp Object.instance_method(:__send__).owner
pp Object.instance_method(:__id__).owner
```

* なので `#__send__` に合わせるのであれば `#__id__` も同様に警告が出るほうがよいのがモチベーションになっているみたいですね
* コメントでは `#__id__` に対する警告を追加すること自体は肯定的なんですが `#object_id` への警告を削除する方は否定的みたいですね
* `#object_id` は割と一般的に利用されており `#object_id` が再定義されることで意図しない動作につながる可能性があります
    * https://bugs.ruby-lang.org/issues/20912#note-5
    * もし `#object_id` が再定義される前提であれば `#__id__` を利用するようにする必要がある
* このチケットでは `#__id__` が再定義、もしくは削除されたときのみ警告を出すようになりました
* この変更は開発版の Ruby 3.4-dev ですでに実装済みです
* ちなみにコメントで `#__id__` と `#object_id` の2つが存在している経緯が書いてありました
    * 元々は `Object#id` だけが存在していた
    * `Object#id` が再定義された場合を考慮して `Object#__id__` を追加した
    * `Object#object_id` も追加された
        * これは `#__id__` の見た目がひどかったので変わりに `#object_id` が追加されたみたいですね
    * `Object#id` が削除された
    * 今に至る
    * https://bugs.ruby-lang.org/issues/20912#note-5




--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



## [[Bug #20906] Segmentation Fault in compile_keyword_arg](https://bugs.ruby-lang.org/issues/20906)

* Ruby 3.3 で以下のコードを実行するとクラッシュするというバグ報告

```ruby
a, b[c: nil] = d
```

* これなんですが Ruby 3.4 だと `parse.y` でも `prism` でもシンタックスエラーになるみたいですいね


```shell
$ ruby -v --parser=prism -e "a, b[c: nil] = d"
ruby 3.4.0dev (2024-12-01T08:31:10Z master 96fac34797) +PRISM [x86_64-linux]
-e: -e:1: syntax error found (SyntaxError)
> 1 | a, b[c: nil] = d
    |      ^~~~~~ unexpected keyword arg given in index assignment; keywords are not allowed in index assignment expressions
  2 | 
```

* あと下のコードでも同じように再現するみたいです

```ruby
*a[a:] = 0
```

* [Bug #20218: aset/masgn/op_asgn with keyword arguments](https://bugs.ruby-lang.org/issues/20218) と同じような話しぽいんですかね？


## [[Feature #20899] Reconsider adding `Array#find_map`](https://bugs.ruby-lang.org/issues/20899)

* `Array#find_map` を再検討するチケット
* 以前も [[Feature #8421] add Enumerable#find_map and Enumerable#find_all_map](https://bugs.ruby-lang.org/issues/8421) で同じ提案があったんですがそれを再検討するチケットですね
    * こっちは10年以上前のチケット
    * 今だと `#filter_map` があるのでそれを考慮した上で再検討したい、みたいな感じ
* いくつかユースケースが書いてあるんですが例えば以下のように『特定の正規表現にマッチした最初の文字列を取得する』みたいなことがあげられていますねー

```ruby
list = ['some 123', 'list 234', 'of 345', 'strings 456']

list.find_map{ |s| s[/\Aof (\d+)\z/, 1] } # => "345"
```

* あとは個人的なユースケースとしては以下みたいに『特定のメソッドが `nil` じゃないやつを探す』とかかなあ

```ruby
# address が存在している最初の情報を取得する
users.find_map { _1.address }
```




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



## [[Feature #20894] Allow `Range#last(n)` for beginless ranges with Integer end](https://bugs.ruby-lang.org/issues/20894)

* 先端無限Range のときに `Range#last(n)` を許容する提案
* `Range#last(n)` は終端から `n` 個分の要素を抽出するメソッドですね

```ruby
# 終端から3つの要素を配列で取得する
pp (1..10).last(3)
# => [8, 9, 10]
```

* ただし、先端無限の場合はこれがエラーになります

```ruby
# error: can't iterate from NilClass (TypeError)
(..10).last(3)
```

* これ、結構挙動がややこしくて引数がない場合はエラーにならないんですよね

```ruby
pp (..10).last
# => 10
```

* Ruby 3.3 では以下のように `#reverse_each` が利用できるようになったので、これが許容されるのであれば `Range#last(n)` も受け入れられるべきと書かれていますねー

```ruby
pp (..10).reverse_each.first(3)
# => [10, 9, 8]
```

* ちなみに `Range#max` でも似たような挙動になります

```ruby
# OK: 動作する
pp (1..10).max(3)   # => [10, 9, 8]

# OK: 動作する
pp (1..10).max   # => 10

# NG: error: cannot get the maximum of beginless range with custom comparison method (RangeError)
pp (..10).max(3)
```

* ここら辺むずかしい…
* 似たような話がどこかの issues で議論されていた気がするけどどこだったかなあ…



## [[Feature #20884] reserve "Ruby" toplevel module for Ruby language](https://bugs.ruby-lang.org/issues/20884)

* トップレベルに `Ruby` モジュールを追加する（予約しておく）提案
* Ruby には以下のような定数があるんですがそれを `Ruby` モジュール配下に定義する、みたいな使い方を想定しています

```ruby
RUBY_VERSION
RUBY_RELEASE_DATE
RUBY_PLATFORM
RUBY_PATCHLEVEL
RUBY_REVISION
RUBY_COPYRIGHT
RUBY_ENGINE
RUBY_ENGINE_VERSION
RUBY_DESCRIPTION
```

* `RUBY_VERSION` を `Ruby::VERSION` で参照するような感じですね

```ruby
module Ruby
  VERSION = ::RUBY_VERSION
end
```

* 他にも Ruby 固有の機能などを `Ruby` モジュールの配下にする構想とかもあるみたいです
    * 例えば `Thread::Backtrace::Location` を `Ruby::Backtrace::Location` にするなど
* これは普通にあるとよさそうですねーどこに機能を追加するのか、みたいな話で止まってしまうことも多いのでそういうときに広く追加できる場所とかがあると便利そうです
* コメントを見てみても全体的に概ね肯定的な意見が多いです



## [[Bug #20873] `printf("%f")` returns wrong result for `Rational` with `FIXNUM_MIN`](https://bugs.ruby-lang.org/issues/20873)

* `FIXNUM_MIN` が含まれている `Rational` に対して `printf("%f")` を行うと意図しない結果になるバグ報告

```ruby
require 'rbconfig/sizeof'

fmin, fmax = RbConfig::LIMITS.values_at("FIXNUM_MIN", "FIXNUM_MAX")
rational = Rational(fmin, fmax)

pp rational   # => (-4611686018427387904/4611686018427387903)

# - が1つ多い
pp sprintf("%f", rational)   #=> --1.000000
```

* このバグはすでに開発版の Ruby 3.4-dev だと修正済みです


## [[Feature #20885] String#gsub?](https://bugs.ruby-lang.org/issues/20885)

* `sub / gsub` を実行したときに一致する場合は新しい文字列を返し、そうでない場合は `nil` を返す `String#gsub?` を追加する提案
* `String#gsub!` の戻り値がこの挙動になっており `#gsub?` は `str.dup.gsub!(...)` と同等の挙動になります
* 提示されているユースケースは以下の通り

```ruby
# gsub で文字列が変更されたかどうかを確認する
newstr = str.gsub?(rx,repl) or raise "str did not contain expected value"

# 文字列が変更されたときに処理を実行する
if str = obj.title.gsub?(rx, repl)
  obj.title = str
  obj.save
end

# 変更がない場合は新しい文字列の割当を防ぐ (str がそのまま代入される)
str = str.gsub?(rx, repl) || str
```

* どういうときに使うんだろう？と思っていたんですがユースケースを見るとままあるんですかね？
* とはいえ `#gsub?` っていう名前だと `true / false` が返ってくる印象がめちゃくちゃ強いのですごい違和感がある…
* 本当は既存の `#gsub` の戻り値がこういう挙動になっているとよいと思うんですがいまから変えるのは難しいですしねえ
* ちなみに `#gsub?` を利用すると `#gsub / gsub!` が以下のように簡素に実装できるともコメントされていますねーはえー

```ruby
def gsub!(...)
  modified = gsub?(...) and replace(modified)
end

def gsub(...)
  gsub?(...) or dup
end
```



## [[Feature #20794] Expose information about the currently running GC module](https://bugs.ruby-lang.org/issues/20794)

* 現在実行中の GC に関する情報が取得できるようにする提案
* Ruby 3.4 では GC に関するいくつかの開発が行われているんですがその一貫みたいですね？
* 開発版の Ruby 3.40-dev では以下のように `GC.config` で GC の情報が取得できるようになります

```ruby
pp GC.config
# => {rgengc_allow_full_mark: true, implementation: "default"}
```


## [[Feature #20882] Provide Boolean(...)](https://bugs.ruby-lang.org/issues/20882)

* `Integer(...)` や `Float(...)` と同じような `Boolean(...)` メソッドを追加する提案
    * `Boolean` クラスを追加するのではなくて `true / false` `Boolean()` メソッドを追加する想定
* 以下のように何かしらの値から `true / false` に変換するイメージですね

```ruby
# ENV["SOME_FEATURE"] がない場合
Boolean(ENV["SOME_FEATURE"]) # => false

# ENV["SOME_FEATURE"] がない場合だけどデフォルト値が渡された場合
Boolean(ENV["SOME_FEATURE"], true) # => true

# false ぽい値がある場合
ENV["SOME_FEATURE"] = "0"
Boolean(ENV["SOME_FEATURE"], true) # => false

# true ぽい値がある場合
ENV["SOME_FEATURE"] = "1"
Boolean(ENV["SOME_FEATURE"]) # => true
```

* こういうの、普通にほしいんですが何を `true` として扱うのがむずかしそうですねえ
    * `0` や `""` をどうするかとか
    * `t` や `yes` `on` みたいな話もあるみたい
    * https://bugs.ruby-lang.org/issues/20882#note-5



## [[Bug #20871] Including methods in Enumerable doesn't make them available in Array](https://bugs.ruby-lang.org/issues/20871)

* `3.3.5 -> 3.3.6` にアップデートしたら以下のように `Enumerable` に対して `include` したモジュールが `Array` に反映されていないというバグ

```ruby
module CoreExt
  module Enumerable
    def average
      sum(&:to_f) / count if any?
    end

    # def ...
  end
end

# Enumerable に include することで Enumerable が include されている Array などにメソッドを組み込みたい
Enumerable.include CoreExt::Enumerable

# しかし、これが動作しないというバグ
[].average
```

* これなんですがいくつかの前提条件があるらしく最小構成だと以下のコードで再現するみたいです
    * https://bugs.ruby-lang.org/issues/20871#note-5

```ruby
module Bar; end
Enumerable.prepend Bar

class Foo
  include Enumerable
end

module Ext
  def foo
    "foo"
  end
end

Enumerable.include(Ext)

[].foo
# 3.3.5 => no error
# 3.3.6 => error: undefined method `foo' for an instance of Array (NoMethodError)
```

* このバグは `3.2.6` `3.3.6` `master` で再現しているみたいですね
    * https://bugs.ruby-lang.org/issues/20871#note-8
* このバグは開発版の Ruby 3.4-dev ではすでに修正済みです


## [[Bug #20880] Hash allows array-type key duplicates](https://bugs.ruby-lang.org/issues/20880)

* 次のような書き方をしたときに `Hash` のキーが重複するというバグ報告

```ruby
# Array をキーとして Hash に値を割り当てる
ary = [1, 2]
hash = { ary => "hoge" }

pp hash
# => {[1, 2]=>"hoge"}


# ary の値を書き換えた上でそれをキーとして値を割り当てる
ary << 3
hash[ary] = "foo"

# [1, 2, 3] のキーが2つある
pp hash
# => {[1, 2, 3]=>"hoge", [1, 2, 3]=>"foo"}
```

* これなんですが意図する挙動になっておりキーのハッシュ値が変わってしまった場合には正しく値を取得することができなくなるからです

```ruby
ary = []

# この時点でのハッシュ値をキーとする
pp ary.hash   # => -1318494078152444009
hash = { ary => 1 }

# 破壊的な変更があるとハッシュ値も変わってしまうので hash から値を取り出せなくなる
ary << 1
pp ary.hash    # => -433313666350349196
pp hash[ary]   # => nil
```

* こういう場合は `Hash#rehash` でハッシュ値を再計算する必要があります
    * [Hash#rehash (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/Hash/i/rehash.html)

```ruby
ary = []

hash = { ary => 1 }

ary << 1

# rehash したあとであればキーが破壊的に変更されたあとでも正しく参照できる
hash.rehash
pp hash[ary]   # => 1
```




## [[Feature #20715] `Ractor.[]` and `Ractor.[]=` to access Ractor local storage](https://bugs.ruby-lang.org/issues/20715)

* `Ractor` ローカルな値を参照する `Ractor.[] / Ractor.[]=` を追加する提案
* 現状でも `Ractor#[] / Ractor#[]=` が存在しているんですがこれも `Ractor` ローカルな値を参照しているので実際には `Ractor` のインスタンスオブジェクトには依存していないみたいですね

```ruby
p Ractor.current   # => #<Ractor:#1 running>
Ractor.current[:foo] = 42

Ractor.new{
  # トップレベルの Ractor.current と同じオブジェクトを返す
  p Ractor.main   # => #<Ractor:#1 running>

  # ただし、トップレベルで保存した値は参照されない
  p Ractor.main[:foo]   # => nil
}.take
```

* なので `Ractor.current` を経由して参照するよりも `Ractor.[] / Ractor.[]=` で参照するほうが効率がよいとのこと
* これは開発版の Ruby 3.4-dev ですでに対応済です

```ruby
# Ractor[]= で値を割り当てて
Ractor[:foo] = 42

Ractor.new{
  Ractor[:foo] = "other"
  p Ractor[:foo]   # => "other"
}.take

# Ractor[] で参照できる
# この値は他の Ractor 内での値は反映されない
p Ractor[:foo]   # => 42
```



## [[Bug #20868] Method#hash changes after compaction](https://bugs.ruby-lang.org/issues/20868)

* `GC.verify_compaction_references` を呼び出すと `Method#hash` の値が変わってしまうというバグ報告
    * `GC.verify_compaction_references` は『コンパクションの参照の一貫性を検証する』メソッドらしい
        * [GC.verify_compaction_references (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/GC/s/verify_compaction_references.html)
    * 厳密にいうと `expand_heap: true, toward: :empty` が設定されている

```ruby
def a; end

def get_hash
  method(:a).hash
end

# ここは同じ hash 値が返ってくる
pp get_hash   # => 161273473511457888
pp get_hash   # => 161273473511457888

GC.verify_compaction_references(expand_heap: true, toward: :empty)

# GC.verify_compaction_references を呼び出したあとに hash 値が変わってしまう
pp get_hash   # => 1383780992949518684
```

* hash 値が変わってしまうとハッシュテーブルで保持しているときに意図しない挙動になる可能性がある、とのこと
* この問題は開発版の Ruby 3.4-dev で修正済みです

```ruby
def a; end

def get_hash
  method(:a).hash
end

pp get_hash   # => 161273473511457888

GC.verify_compaction_references(expand_heap: true, toward: :empty)

# Ruby 3.4 だと値は変わらない
pp get_hash   # => 1383780992949518684
```


## [[Feature #20864] Allow `Kernel#warn` to accept `**options` and pass these to `Warning.warn`.](https://bugs.ruby-lang.org/issues/20864)

* `Kernel#warn` で `**options` を受け入れ `Warning.warn` にそれを渡すことを追加する提案
* 以下のように `#warn` を呼び出したときに付随するデータを渡すとその内容がいい感じに出力されるイメージですかね？

```ruby
begin
  ...
rescue => error
  warn "Something went wrong!", exception: error
end
```

* モチベーションとしては出力内容を構造化してよりわかりやすくしたい、みたいなところみたいですね
    * 具体的な実装とか出力内容とかは特に提示はされてなかったんですがそれはこれからみたい
* 個人的にはわかりやすいなーと思いつつ現状の `Warning.warn` が `category:` キーワード引数を受け取るようになっているので単純に `Warning.warn` に `**options` を移譲すると意味が違ってきそうなんですよねえ
    * [Warning.warn (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/Warning/s/warn.html)
    * 同様のことがコメントにもかかれていますね
        * https://bugs.ruby-lang.org/issues/20864#note-10

```ruby
module Warning
  # category: を受け取ることを期待している
  def self.warn(message, category: nil)
    super("#{category} warning : #{message.chomp}!!!\n")
  end
end
```

* 以下のような専用のキーワード引数を追加することが代替として上げられていますね

```ruby
# extra に構造化したい値を渡す
warn "something went wrong", extra: { exception: }
```



## [[Bug #20858] multiple parallel assignments are inconsistent](https://bugs.ruby-lang.org/issues/20858)

* 次のように1行に複数の代入式がある場合は右辺の値がそれぞれの変数に代入されます

```ruby
a = b = c = 1
pp a:, b:, c:
# => {:a=>1, :b=>1, :c=>1}
```

* 同じく次のように『左辺と右辺に複数の変数や値がある場合』にはそれぞれ別々の変数に値が代入されます

```ruby
a, b = 1, 2
pp a:, b:
# => {:a=>1, :b=>2}
```

* 上記を前提としたときに次のように『複合的な代入式』の場合に意図する挙動にならないというチケットになります

```ruby
a, b = c, d = 3, 4

pp a:, b:, c:, d:
# => ???
```

* これなんですが実際に動かしてみると `undefined local variable or method `c' for main (NameError)` とエラーになります
* なので次のように事前に `a ~ d` の変数を定義しておくと次のような結果になります

```ruby
a = b = c = d = "hoge"
a, b = c, d = 3, 4

pp a:, b:, c:, d:
# => {:a=>"hoge", :b=>3, :c=>"hoge", :d=>3}
```

* これなんですが現状の Ruby では `a, b = c, (d = 3), 4` のように解釈されるためです
    * https://bugs.ruby-lang.org/issues/20858#note-1

```ruby
a = b = c = d = "hoge"

# これと同じ結果になる
# a, b = [c, (d = 3), 4] みたいに解釈するとわかりやすいかも
a, b = c, (d = 3), 4

pp a:, b:, c:, d:
# => {:a=>"hoge", :b=>3, :c=>"hoge", :d=>3}
```

* コメントでは `a, b = c, (d = 3, 4)` と解釈されると書いてあるんですがこっちだと結果が異なるのでちょっと違ってそうかも
    * https://bugs.ruby-lang.org/issues/20858#note-1

```ruby
a = b = c = d = "hoge"

a, b = c, (d = 3, 4)

pp a:, b:, c:, d:
# => {:a=>"hoge", :b=>[3, 4], :c=>"hoge", :d=>[3, 4]}
```

* `a = c = 3` `b = d = 4` みたいな挙動になってほしい場合は以下のようなカッコをつけることで期待する代入になります

```ruby
a, b = (c, d = 3, 4)

pp a:, b:, c:, d:
# => {:a=>3, :b=>4, :c=>3, :d=>4}
```

* むずかしいね…


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Bug #20857] Ruby 3.4 seems to have backwards compatibility issues more than its predecessors](https://bugs.ruby-lang.org/issues/20857)

* Ruby 3.4 では `Hash#inspect` の結果が以下のように変更されます

```ruby
homu = { id: 1, name: "homu", age: 14, 1 => "one" }

# => から : に変わったり `=>` の前後にスペースが追加されたり
puts homu.inspect
# Ruby 3.3 => {:id=>1, :name=>"homu", :age=>14, 1=>"one"}
# Ruby 3.4 => {id: 1, name: "homu", age: 14, 1 => "one"}
```

* これの影響によりいずれかのテストが落ちてしまうというチケット
    * `https://github.com/asciidoctor/asciidoctor/issues/4634#issuecomment-2449497487` で影響がでている
    * どちらかというと `=>` のスペースの話で『本当にこれって追加する必要があるのか』みたいなことがコメントされている
* また Fedora では Ruby 3.4 だと528個のパッケージのうち127個のビルドが失敗しているらしい
* 基本的に `#inspect` の結果をテストの期待値として扱うことは推奨はされていないのでこういう影響はしょうがない、ってスタンスではあるみたいですね
    * https://bugs.ruby-lang.org/issues/20857#note-4
* また Fedora の問題は `ASCIIDoctor` 以外は `Hash#inspect` 以外の互換性の問題も大きいみたいですね
    * https://bugs.ruby-lang.org/issues/20857#note-9
    * より詳細な内訳
        * https://bugs.ruby-lang.org/issues/20857#note-12
        * `base64` が存在しない問題は https://bugs.ruby-lang.org/issues/20859 でも議論されています
            * Ruby Core に追加する話だったんですが結局は追加しないことになったみたい
* 互換性の話自体は予想範囲内であるということで Revert 対応などは行われずにこのチケット自体は閉じられています
    * https://bugs.ruby-lang.org/issues/20857#note-19 
* ちなみに `Hash#inspect` の結果をテストで利用したい場合は以下のように対応するとよいとコメントされています
    * https://bugs.ruby-lang.org/issues/20857#note-14

```ruby
# Before
expect(thing).to be == '{"x"=>10}'

# After
expect(thing).to be == {"x"=>10}.to_s
```




## [[Feature #20852] Anonymous HEREDOC blocks](https://bugs.ruby-lang.org/issues/20852)

* 識別子が匿名なヒアドキュメントを定義できるようにする提案
* 通常ヒアドキュメントは以下のような識別子〜識別子までをドキュメントとして扱う機能です

```ruby
Markdown.render <<~MARKDOWN
  # ヒアドキュメント

  MARKDOWN ~ MARKDOWN までがヒアドキュメントとして定義される

  1. mami
  2. mado
  3. homu
MARKDOWN
```

* これを次のように `<<~` から `~>>` までをヒアドキュメントとして扱えるようにする提案

```ruby
Markdown.render <<~
  # ヒアドキュメント

  MARKDOWN ~ MARKDOWN までがヒアドキュメントとして定義される

  1. mami
  2. mado
  3. homu
~>>
```

* モチベーションとしては `MARKDOWN` が重複しているのが冗長だったり名前付けするのが手間みたいなところが上げられていますね
* 個人的にはエディタのスニペット機能を使っているので書く事自体は手間でないのと名前は `EOS` でもう統一しているので特に現状でも不便さはないんですよねえ
* 現状でもすでにヒアドキュメントの構文が複雑なのでこの提案は Reject されています
    * https://bugs.ruby-lang.org/issues/20852#note-1




## [[Feature #20818] Allow passing a block to Hash#store (to update current value)](https://bugs.ruby-lang.org/issues/20818)

* `Hash#store` にブロックを渡せるようにする提案
* `Hash#store` は `Hash#[]=` と同等で特定のキーに値を割り当てるメソッドです

```ruby
hash = {}
hash.store(:name, "homu")
pp hash
# => {:name=>"homu"}
```

* `Hash#store` にブロックを渡した場合は以下のような値をブロックの引数で受け取り、ブロックの戻り値がそのキーに割り当てられます
    * ブロックの引数に現在の値が渡される
    * 現在の値がなければ `Hash#default` の値が渡される

```ruby
hash = { name: "homu" }

# :name のキーに対して値を割り当てる
# ブロックの引数は現在の値を受け取る
# ブロックの戻り値が新しい値として割り当てられる
hash.store(:name) { |v|
  v # => "homu"
  "mami"
}
hash[:name]   # => "mami"

# キーがなければ Hash#default の値がブロックで渡される
# 意図的に設定されていなければ `nil` を受け取る
hash.store(:age) { |v|
  v # => nil
  14
}
hash[:age]   # => 14

# #default の値に依存して設定もできる
hash.default = 100
hash.store(:id) { |v|
  v # => 100
  v + 1
}
hash[:id] # => 101
```

* モチベーションとしては例えばキーがない場合に次のように `Hash#[]=` と `Hash#[]` を呼び出すことがあると思うんですが

```ruby
hash[:name] = hash[:name] || "default name"
```

* 今回の `Hash#store` を使うと以下のようにかけるのでパフォーマンスがよい、みたいなところがモチベーションとしてあるみたいです

```ruby
# こっちだとメソッド呼び出しが1つだけになる
hash.store(:name) { _1 || "default name" }
```

* PR もすでにあり実際にどれぐらいパフォーマンスが向上するのかと安全なのかどうか（ブロック内で他のキーの値を書き換えた場合にどうなるのか）みたいなところがコメントされています
    * https://bugs.ruby-lang.org/issues/20818#note-1
* 個人的には `hash[:name] ||= "default name"` の書き味が好きなんですがどれぐらいパフォーマンスを気にする必要がありそうなんですかねー




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



## [[Feature #20815] Fetch for nested hash](https://bugs.ruby-lang.org/issues/20815)

* ネストした `Hash` の値を取得する `Hash#fetch_nested` を追加する提案
* `Hash#dig` とは違ってキーが見つからない場合は例外が発生することを期待する

```ruby
data = { user: { profile: { name: "Alice" } } }

# #fetch を使用した場合
data.fetch(:user).fetch(:profile).fetch(:name)
# => "Alice"

# #fetch_nested を使用した場合
data.fetch_nested(:user, :profile, :name)
# => "Alice"
```

* 例外が発生する `#dig` がほしい！っていう話はたまにみかけますねー
    * [Feature #12282: Hash#dig! for repeated applications of Hash#fetch](https://bugs.ruby-lang.org/issues/12282) とか
    * [Feature #14602: Version of dig that raises error if a key is not present](https://bugs.ruby-lang.org/issues/14602) も
* 他のチケットと重複している、という理由でこのチケット自体は閉じられています
* ちなみにパターンマッチを利用すると以下のようにかけることがコメントされてますねー
    * https://bugs.ruby-lang.org/issues/20815#note-3

```ruby
data = { user: { profile: { name: "Alice" } } }

data => user: { profile: { name: } }
p name #=> "Alice"

# error: {:user=>{:profile=>{:name=>"Alice"}}}: key not found: :age (NoMatchingPatternKeyError)
data => user: { profile: { age: } }
```

* もうパターンマッチでいいんじゃないかな…




## [[Feature #20811] `warning: in a**b, b may be too big` is really helpful?](https://bugs.ruby-lang.org/issues/20811)

* 以下のようなコードを実行すると警告が表示され `Infinity` が返ってくる
    * これは最近発見された最大の素数ですね

```ruby
# warning: in a**b, b may be too big
p 2 ** 136279841 - 1
# => Infinity
```

* これが妥当かどうかを議論するチケット
* 流石に処理できないなら例外とかが発生してほしい気がするけども
* ちなみにこれは `#**` でのみ `Infinity` を返し、以下のようなコードは計算結果を返す

```ruby
(2 ** 32537661) * 2
1 << 32537662
```



## [[Bug #20795] Timeout method doesn't check for negative time values](https://bugs.ruby-lang.org/issues/20795)

* `Timeout.timeout` に負の値が設定できるバグ報告

```ruby
require 'timeout'

# Case 1: すぐに処理が終了する場合
Timeout.timeout(-5) do
  puts "すぐに終了する処理"
end

# Case 2: 処理内で sleep している場合
Timeout.timeout(-5) do
  sleep(10)
end
```

* `Case 1` の方は特に問題ないが `Case 2` の方は `Timeout::Error` が発生する
* ブロックの処理によって動作が一貫性でないことが問題点としてあげられていますね
* 現状だと https://github.com/ruby/timeout の方に報告するように誘導されています
    * https://bugs.ruby-lang.org/issues/20795#note-1
    * https://github.com/ruby/timeout/pull/51 でやり取りされています



## [[Bug #20797] UTC offset seconds part is not checke](https://bugs.ruby-lang.org/issues/20797#change-110163)

* `Time.new` のオフセットを設定するときに秒数までチェックしていないバグ報告
* 次のようにオフセットに分を指定しているときにはエラーになる

```ruby
# error: 'Time#initialize': "+HH:MM", "-HH:MM", "UTC" or "A".."I","K".."Z" expected for utc_offset: +09:99 (ArgumentError)
Time.new(2024, 12, 25, 0, 0, 0, "+09:99")
```

* しかし、秒数を指定した場合はエラーにならないバグ

```ruby
# こっちはエラーにならない
pp Time.new(2024, 12, 25, 0, 0, 0, "+09:00:99").strftime("%::z")
# => "+09:01:39"
```

* これは以前から存在しているバグみたいですね
* 開発版の Ruby 3.4-dev だと修正済



## [[Bug #20809] Ripper fails to parse/tokenize nested heredocs within embexpr](https://bugs.ruby-lang.org/issues/20809)

* 以下のコードを Ripper で構文解析すると `"s333\n"` と `"s4444"` が誤って結合されてしまうとういうバグ報告

```ruby
require 'ripper'

code1 = '<<HEREDOC1
s1
#{<<HEREDOC2}s333
s22
HEREDOC2
s4444#{55555}
HEREDOC1'

pp Ripper.tokenize(code1)
# => ["<<HEREDOC1", "\n", "s1\n", "\#{", "<<HEREDOC2", "}", "s333\n" + "s4444", "s22\n", "HEREDOC2\n", "\#{", "55555", "}", "\n", "HEREDOC1"]

puts Ripper.tokenize(code1).join
# => <<HEREDOC1
#    s1
#    #{<<HEREDOC2}s333
#    s4444s22             # <- s4444 がここに来てる
#    HEREDOC2
#    #{55555}
#    HEREDOC1
```

* 本来は `s4444#{55555}` の行にいる `s4444` が `s4444s22` に移動しているみたいですね？

  


## [[Feature #15381] Let double splat call `to_h` implicitly](https://bugs.ruby-lang.org/issues/15381)

* `**obj` のときに暗黙的に `obj.to_h` を呼び出すようにする提案
* 現状だと `**obj` のときには `obj.to_hash` が内部で呼び出されます

```ruby
class X
  # ** でこれが呼び出される
  def to_hash
    { a: 1 }
  end
end

p **X.new
# => {:a=>1}
```

* これを `#to_hash` ではなくて `#to_h` の呼び出しにする提案
* `*obj` だと `obj.to_a` を呼び出すのでちょっとややこしいんですよね、これ

```ruby
class X
  # * でこれが呼び出される
  def to_a
    [1, 2]
  end
end

p *X.new
# => [1, 2]
```

* 6年前のチケットなんですが最近話題になってました
* チケットの内容よりも `#to_a, to_h` と `#to_ary, to_hash` の責務の話などが議論されてて読んでて面白かったです
    * `#to_a` は『〜に変換可能』という意味で `#to_ary` は『〜と同一である』みたいな話とか
* どこまでを明示的に扱って、どこまでを暗黙的に扱うのかは悩ましい部分ではありますねえ
* あと面白い提案としては `**@` を追加する提案もありました
    * https://bugs.ruby-lang.org/issues/15381#note-11
    * これだといろいろと汎用性が広がりそうですねー




## [[Bug #20807] String#gsub fails when called from string subclass with a block passed](https://bugs.ruby-lang.org/issues/20807)

* 以下のようにサブクラスで `String#gsub` を再定義したときに `#gsub` のブロック内で `Regexp.last_match` が取得できないというバグ報告

```ruby
def call_gsub(str)
  str.gsub(/^./) {
    # ブロック内でマッチした値を取得する
    pp Regexp.last_match
  }
end

class MyString < String
  def gsub(*args, &block)
    super(*args, &block)
  end
end

text = 'hoge'

call_gsub(String.new(text))
# => #<MatchData "h">

call_gsub(MyString.new(text))
# => nil
```

* これなんですが `Regexp.last_match` などの正規表現関連のグローバル値は複数のフレームに渡って動作しないのが起因みたいですね
    * https://bugs.ruby-lang.org/issues/20807#note-1
* 今回のケースだと `#gsub` を再定義しているので `MyString#gsub` 内でのみ参照できるらしい

```ruby
def call_gsub(str)
  str.gsub(/^./)
  pp call_gsub: Regexp.last_match
end

class MyString1 < String
end

class MyString2 < String
  def gsub(*args, &block)
    # このメソッド内で gsub でマッチしたときの正規表現の情報が参照できる
    super(*args, &block)
  ensure
    pp ensure: $~
  end
end

text = 'hoge'

# #gsub を再定義していない場合はブロック内でも取得できる
call_gsub(MyString1.new(text))
# {call_gsub: #<MatchData "h">}

# #gsub を再定義している場合はそのメソッド内で値を取得できる
call_gsub(MyString2.new(text))
# {call_gsub: nil}
# {ensure: #<MatchData "h">}
```

* `call_gsub` メソッドだけ見ると `String#gsub` で `Regexp.last_match` が利用できる期待値なのでこういうケースはなかなか気づきづらそうですねえ
* 相当なエッジケースとはいえ、ハマると一生気づかなさそう…



## [[Bug #20799] Bug in forwarding to struct methods](https://bugs.ruby-lang.org/issues/20799)

* 開発版の Ruby 3.4-dev で以下のコードがクラッシュするというバグ報告

```ruby
Thing = Struct.new(:value)

Obj = Thing.new("ok")

def delegate(...)
  Obj.value(...)
end

def no_args
  delegate
end

def splat_args(*args)
  delegate(*args)
end

no_args
# これを呼び出したときにクラッシュする
splat_args
```

* 一度 `Struct` のメソッドに転送引数を渡すあたりでバグってるらしいのかな？
* この不具合は開発版の Ruby 3.4-dev ですでに修正済みです




------------------------------------------------------------------------------------------------------------------------------------


## [[Bug #20788] Prism issues unused variable warnings for negative line numbers](https://bugs.ruby-lang.org/issues/20788)

* Ruby 3.4-dev + prism で次のコードを実行したときに行数がマイナスの警告が出力される

```ruby
Object.class_eval(<<END, nil, -2)
def a(locals)
  foo = locals[:foo]
  2
end
END
__END__
output:
(eval at test.rb:1):-1: warning: assigned but unused variable - foo
```

* なぜマイナスの行数が表示されるのかというと `class_eval` でマイナスの行数を指定しているからですね
* `class_eval` に渡す行数が `1` なら以下のようになります

```ruby
Object.class_eval(<<END, nil, 1)
def a(locals)
  foo = locals[:foo]
  2
end
END
__END__
output:
  (eval at test.rb:1):2: warning: assigned but unused variable - foo
```

* これは `parse.y` だと再現しないみたいですね
* 最新の開発版の Ruby 3.4 だと行数がマイナスの警告は出力されないように対応されたみたいです
    * https://bugs.ruby-lang.org/hearts/hearted_users?object_id=110121&object_type=journal



## [[Feature #18242] Parser makes multiple assignment sad in confusing way](https://bugs.ruby-lang.org/issues/18242)

* 次のように `and / or` と多重代入を組み合わせた場合に意図せずシンタックスエラーになるというバグ報告

```ruby
# これは動作する
1 < 2   and a = 2     # Works
1 < 2   or a = 2      # Works
1 < 2   and (a, b = 2, 1)    # Works
1 < 2   and (a, b = [2, 1])  # Works
2 < 1   or (a, b = 2, 1)     # Works
2 < 1   or (a, b = [2, 1])   # Works

# 以下は動作しない
1 < 2   and a, b = 2, 1      # SyntaxError
1 < 2   and a, b = [2, 1]    # SyntaxError
1 < 2   and (a, b) = 2, 1    # SyntaxError
1 < 2   and (a, b) = [2, 1]  # SyntaxError
(1 < 2) and a, b = 2, 1      # SyntaxError
(1 < 2) and a, b = [2, 1]    # SyntaxError
(1 < 2) and (a, b) = 2, 1    # SyntaxError
(1 < 2) and (a, b) = [2, 1]  # SyntaxError
2 < 1   or a, b = 2, 1       # SyntaxError
2 < 1   or a, b = [2, 1]     # SyntaxError
2 < 1   or (a, b) = 2, 1     # SyntaxError
2 < 1   or (a, b) = [2, 1]   # SyntaxError
(2 < 1) or a, b = 2, 1       # SyntaxError
(2 < 1) or a, b = [2, 1]     # SyntaxError
(2 < 1) or (a, b) = 2, 1     # SyntaxError
(2 < 1) or (a, b) = [2, 1]   # SyntaxError

# 以下のような後置 if / unless は意図する挙動になる
a, b = 2, 1     if 1 < 2     # Works
a, b = [2, 1]   if 1 < 2     # Works
(a, b) = 2, 1   if 1 < 2     # Works
(a, b) = [2, 1] if 1 < 2     # Works
(a, b = [2, 1]) if 1 < 2     # Works
a, b = 2, 1     unless 2 < 1 # Works
a, b = [2, 1]   unless 2 < 1 # Works
(a, b) = 2, 1   unless 2 < 1 # Works
(a, b) = [2, 1] unless 2 < 1 # Works
(a, b = [2, 1]) unless 2 < 1 # Works
```

* これはバグというか新しい機能追加になるみたいですね？
* すでにパッチはあるみたいですが機能追加なので matz の承認待ちみたい
* 後置 `if / unless` の変わりに `and / or` でかけると便利なんですかねー




## [[Feature #20792] String#forcible_encoding?](https://bugs.ruby-lang.org/issues/20792)

* 指定したエンコーディングが `String#force_encoding` で有効かどうかを判定する `String#forcible_encoding?` を追加する提案
* イメージとしては以下のような挙動になる想定

```ruby
def forcible_encoding?(enc)
  original = encoding
  # 一度 force_encoding で変化し、それが有効かどうか判定する
  result = force_encoding(enc).valid_encoding?
  # その後また戻す
  force_encoding(original)
  result
end
```

* インターフェースをどうするのかとパフォーマンスの面で議論が進んでいるみたいですね
    * インターフェースに関しては `String` に生やすのか `Encoding::UTF_8.valid_sequence?(str)` みたいに `Encoding` から呼び出せるようにするのか
    * パフォーマンスに関しては `.dup` するあたりの話がされている




## [[Feature #20793] I propose allowing multiple arguments to be passed to the .is_a? Method imply "OR" semantics:](https://bugs.ruby-lang.org/issues/20793)

* 以下のように `Object#is_a?` に複数のクラスを渡せるようにする提案

```ruby
# name が String か Symbol のインスタンスであれば true を返す
name.is_a? String, Symbol
```

* 現状だと以下のような形で書く必要がある

```ruby
[String, Symbol].include?(name.class)
```

* これなんですがパターンマッチの `in` 演算子を利用すれば1発で判定できるんですよね

```ruby
pp (42 in String | Symbol)      # => false
pp ("foo" in String | Symbol)   # => true
pp (:homu in String | Symbol)   # => true
```

* コメントでも同様のことが書いてあり、とりあえずこれでよさそう
    * https://bugs.ruby-lang.org/issues/20793#note-2


## [[Bug #20790] Syntax acceptance of `*x = p rescue p 1` is different between parse.y and prism](https://bugs.ruby-lang.org/issues/20790)

* `*x = p rescue p 1` が `parse.y` と `prism` で構文が有効かどうかが異なるというバグ報告
* 以下のコードは `parse.y` と `prism` で同じ挙動になります

```ruby
# OK
*x = p 1 rescue p 1
# OK
x = p 1 rescue p 1

# NG
x = p rescue p 1
```

* しかし、次のコードは `parse.y` だとエラーにならないが `prism` だとエラーになります。

```ruby
*x = p rescue p 1
```

* これ Ruby 3.3 で `prism` を使用した場合はエラーにならなかったのでエラーにならないが正しいんですかね？




## [[Feature #20786] Flow chaining with "then" keyword](https://bugs.ruby-lang.org/issues/20786)

* `then` キーワードを使って処理をチェーンしたいという提案
* どういうことかというと以下のようなコードに対して

```ruby
def include?(other)
  other = coerce_other(other)
  return false unless other.family == family
  begin_addr <= other.begin_addr && end_addr >= other.end_addr
end
```

* 以下のように `then` キーワードで処理結果を取得し、それに対してチェーンしていくらしい

```ruby
def include?(other)
  begin
    coerce_other(other)
  then => coerced  # then => name で値を取得する
    return false unless coerced.family == family
    coerced
  then => it
    begin_addr <= it.begin_addr && end_addr >= it.end_addr
  end
end
```

* 更に `begin` を省略したり `it` を使った例も書かれています

```ruby
def include?(other)
  coerce_other(other)
then 
  it.family == family ? it : false
then
  begin_addr <= it.begin_addr && end_addr >= it.end_addr
end
```

* 構文としては以下みたいなイメージみたいです
    * `begin ~ end` の中で `then` を使って処理を分割する
    * `then` の直前の式の結果が真であれば次の `then` が呼び出されて式の結果が渡される
    * `begin ~ end` の結果は最後の式の結果が返ってくる
* パッと見、 `#then` でチェーンすればいいんじゃない？と思ったけど偽の場合はスキップしたいので全く同じにはかけないのかな？

```ruby
def include?(other)
  coerce_other(other)
    .then { |coerced|
      coerced.family == family ? coerced : false
    }
    # 上の then の戻り値が false の場合は then を呼んでほしくない
    .then { |it|
      begin_addr <= it.begin_addr && end_addr >= it.end_addr
    }
end
```

* 個人的にはよくわからん構文に見えるので普通に『偽のときはブロックは呼ばれない』 `#then` メソッドとか定義するといいんじゃないかなー

```ruby
module Kernel
  def chain(...) = self.then(...)
end

class NilClass
  def chain(...) = self
end

class FalseClass
  def chain(...) = self
end

# これはブロックが呼ばれる
pp 42.chain { _1 + _1 }

# これはブロックが呼ばれず、レシーバを返す
pp nil.chain { 42 }
pp false.chain { 42 }

def include?(other)
  coerce_other(other)
    .chain { |coerced|
      coerced.family == family ? coerced : false
    }
    # 上の chain が false を返した場合でもブロックが呼ばれない
    .chain { |it|
      begin_addr <= it.begin_addr && end_addr >= it.end_addr
    }
end
```

* 個人的には新しい構文を追加するよりもこっちのほうがわかりやすいと思う




## [[Bug #20764] Forwarding parameter `...` is wrongly allowed in lambda](https://bugs.ruby-lang.org/issues/20764)

* ブロックの引数では本来 `(...)` 引数は受け取ることができないので以下のような `lambda` 構文のコードはエラーになります

```ruby
-> (...) {}
__END__
output
test.rb: --> test.rb
unexpected `...` when the parent method is not forwarding
> 1  -> (...) {}
test.rb:1: syntax error, unexpected ..., expecting ')' (SyntaxError)
-> (...) {}
    ^~~
```

* なので以下のような `lambda` 構文はすべてエラーになります

```ruby
-> ... {}
-> (...) {}
-> (a, ...) {}
```

* これは `proc` でも同様です

```ruby
proc { |...| }
__END__
output:
test.rb: --> test.rb
unexpected `...` when the parent method is not forwarding
> 1  proc { |...| }
test.rb:1: syntax error, unexpected (..., expecting '|' (SyntaxError)
proc { |...| }
        ^~~
```

* なんですが以下のような `lambda` 構文だとシンタックスエラーにならないバグ報告

```ruby
# OK: 位置引数 + カッコがない場合
-> a = 0, ... {}
# OK: 位置引数のデフォルト引数がある場合
-> (a = 0, ...) {}

# こっちは NG
proc { |a = 1, ...| }
```

* このバグは開発版の Ruby 3.4 ですでに修正済みです



## [[Bug #20785] Should `a in b, and c` `a in b, or c` `a in b, rescue c` be syntax ok?](https://bugs.ruby-lang.org/issues/20785)

* 以下のコードは `parse.y` だと有効なコードだが `prism` では動作しない

```ruby
tap do
  a in b, and c
  a in b, or c
  a in b, rescue c
end
```

* これは `parse.y` だと以下のように解釈されるらしい

```ruby
tap do
  (a in b,;) and c
  (a in b,;) or c
  a in b,;
rescue c
end
```

* これを `parse.y` に合わせるか `prisim` に合わせるのか、というチケット
* なにが正しいかよくわからないんですが何が正しいんですかね……
* `a in b` 自体は1行 in で `, and c` を含むとどうなるのか…？
* `in` を右代入 = 代入式、と捉えると以下のコードになるんですが、これはエラーになるんですよねー

```ruby
a = b, and c
```

* 報告者の方は『以下のコードは `prism` に合わせてエラーになる』 （ `parse.y` は受け入れる）

```ruby
a in b, and c

a in b,
  and c

tap do
  a in b, rescue c
end
```

* 以下のコードは『 `parse.y` に合わせて受け入れる』（ `prism` はエラーになる）

```ruby
tap do
  a in b,
end

tap do
  a in b,
rescue
end
```

* ことを提案していますね
* この提案を受け入れることになりそうなんですが Ruby むずかしい
    * https://bugs.ruby-lang.org/issues/20785#note-4



## [[Feature #20624] Enhance `RubyVM::AbstractSyntaxTree::Node#locations` method and `RubyVM::AbstractSyntaxTree::Location` class](https://bugs.ruby-lang.org/issues/20624)

```ruby
def show(loc)
  p loc.class
  # => RubyVM::AbstractSyntaxTree::Location
  p [loc.first_lineno, loc.first_column, loc.last_lineno, loc.last_column]
  # => [1, 0, 1, 5]
end

node = RubyVM::AbstractSyntaxTree.parse("1 + 2")

pp node

# node.locations.each { show(_1) }
locs = node.locations
loc = locs.first

p [loc.first_lineno, loc.first_column, loc.last_lineno, loc.last_column]
```

```ruby
node = RubyVM::AbstractSyntaxTree.parse("1 + 2")
pp node.locations
pp node.children.last.locations
```


## [[Feature #20768] Add Hash#delete_at](https://bugs.ruby-lang.org/issues/20768)

* `Hash` から指定したキーの要素を削除する `Hash#delete_at` を追加する提案

```ruby
hash = { a: true, b: false }

# キーの値を配列で返す
# キーがない場合は nil を返す
a, c = hash.delete_at(:a, :c) # => [ true, nil ]

# hash からそのキーの要素は取り除かれる
hash # => { b: false }
```

* 上記は右代入でも同じ値を取得ことができるんですが

```ruby
hash = { a: true, b: false }

# 右代入で a: の要素とそれ以外を受け取る
hash => { a:, c:, **rest }

a    # => true
rest # => { b: false }
```

* キーが存在しない場合はエラーになると書いてありますね

```ruby
hash = { a: true, b: false }

# error: {:a=>true, :b=>false}: key not found: :c (NoMatchingPatternKeyError)
hash => { a:, c:, **rest }
```

* こういうキーが存在しない場合は `Hash#delete` に合わせてブロック引数が呼び出される想定らしい
    * [Hash#delete (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/Hash/i/delete.html)

```ruby
attributes = { disabled: true, aria: { label: "label text" } }
aria, data = attributes.delete_at(:aria, :data) { Hash.new }

aria # => { label: "label text" }
data # => {}
attributes # => { disabled: true }
```

* これなんですが、以下のようなコードで同等のことができるとコメントされてますねー
    * https://bugs.ruby-lang.org/issues/20768#note-1

```ruby
hash = { a: true, b: false }

a, c = [:a, :c].map { hash.delete(_1) }
p a      # => true
p c      # => nil
p hash   # => {:b=>false}
```

* こういうのって `Hash#except!` でできなかったけ？と思ったけど `#except` はあるけど `#except!` はないのね
* あと戻り値も『取り除いた値』じゃなくて『取り除かれなかった値』が返ってきますね

```ruby
hash = { a: true, b: false }
pp hash.except(:b, :c)
# => {:a=>true}
```

* パッとユースケースは思いつかないけどあればなんか使いそうなメソッドではあるかな〜〜〜




----------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Feature #20769] Add `Hash#transform_value`](https://bugs.ruby-lang.org/issues/20769)

* `Hash#transform_value` を追加する提案
* 既存で `Hash#transform_values` はすでに存在しており、それは Hash の要素をすべてをイテレーションします

```ruby
data = { a: 1, b: 2, c: 3 }
pp data.transform_values { _1 + _1 }
# => {:a=>2, :b=>4, :c=>6}
```

* `Hash#transform_value` は特定の要素のみを変換する、という目的みたいですね
* 以下のように特定の要素の値を変換する感じです

```ruby
homu = { name: "homu", age: 14 }
pp data.transform_value(:name) { _1.upcase }
# => {:name=>"HOMU", :age=>14}
```

* 現状だと以下のようにかけるらしい

```ruby
homu = { name: "homu", age: 14 }
pp homu.merge(name: homu[:name].upcase)
# => {:name=>"HOMU", :age=>14}
```

* あとコメントだともうちょいシンプルなコードも書いてありますね
    * https://bugs.ruby-lang.org/issues/20769#note-1
    * これはスマート

```ruby
homu = { name: "homu", age: 14 }
pp homu.merge(name: nil) { |_, name| name.upcase }
# => {:name=>"HOMU", :age=>14}
```

* ただ、提案した `Hash#transform_value` は『引数のキーが存在しない場合はブロックを呼ばない』という機能も含めているとのこと
    * https://bugs.ruby-lang.org/issues/20769#note-2
    * これを考慮するなら `#merge` を使用するのはちょっとつらそう
* matz はユースケースがわからない、とコメントしてますねー
    * https://bugs.ruby-lang.org/issues/20769#note-3
* あると便利そうだけど、実際に必要なケースってどれぐらいあるかなー
* 最初にわたしがあげた例だと以下のようにかいちゃいそう

```ruby
homu = { name: "homu", age: 14 }
homu[:name] = homu[:name].upcase
# 破壊的な変更をしていいならこっちでも
# homu[:name].upcase!
```


## [[Feature #20759] No good API to query which parser is being used](https://bugs.ruby-lang.org/issues/20759)

* Ruby の実行中に使用しているパーサーが `prism` かどうかを判定する API がほしいというチケット
* 現状だと以下のような判定はできる

```ruby
pp RUBY_DESCRIPTION
# => "ruby 3.4.0dev (2024-10-10T01:54:26Z master 133bacc0dc) +PRISM [x86_64-linux]"

parser = RUBY_DESCRIPTION =~ /prism/i ? "prism" : "parse.y"
```

* モチベーションとしては実行した ruby と同じオプションでサブプロセスを実行するときに利用したいみたいですね
* API がないのは意図的でエンドユーザはパーサーを気にする必要がないから、みたいな感じですかね？
    * https://bugs.ruby-lang.org/issues/20759#note-2
* それはそれとして現在実行中の ruvby を同じオプションでサブプロセスを実行したい、みたいなのは別チケで起票されていますね
    * [[Feature #6648] Provide a standard API for retrieving all command-line flags passed to Ruby](https://bugs.ruby-lang.org/issues/6648)


## [[Feature #6648] Provide a standard API for retrieving all command-line flags passed to Ruby](https://bugs.ruby-lang.org/issues/6648)

* 実行中の ruby に渡されたすべてのコマンドラインフラグを取得するための API を追加する提案
* モチベーションとしては実行した ruby と同じオプションでサブプロセスを実行するときに利用したいみたいですね
* JRuby はコマンドラインオプションを取得する仕組みはあるけど Java の API を呼び出す必要があったり Rubinius も独自 API を提供しているが VM レベルのフラグが含まれているかどうかはわからないみたいですね
* 12年前のチケットなんですが今年の4月頃からまた議論が活発化しています
    * https://bugs.ruby-lang.org/issues/6648#note-10 このあたり
    * 異なるバージョンの `.ruby-version` があればそれを参照してそのバージョンのスクリプトを再実行する、みたいなことがしたかったらしい
* イメージこんな感じ？

```ruby
RbConfig.ruby        # 実行した ruby のパス
RbConfig.ruby_args   # ruby のコマンドライン引数
RbConfig.script      # 実行中のスクリプト $0 と同等
RbConfig.script_args # スクリプトの引数 ARGV と同等

# こんな感じでサブプロセスを実行する想定
exec(RbConfig.ruby, *RbConfig.ruby_args, *RbConfig.script, *RbConfig.script_args)
```

* また https://bugs.ruby-lang.org/issues/6648#note-23 では『コマンドラインを解析して `Kernel#exec` するのではなくて『より専用の API を追加する』ほうがいいのでは』ともコメントされてますね
    * Windows 関連で `Kernel#exec` を経由して実行するのはよくないのでは？という話がでてきてます
* いろいろと議論されていたんですが現状だと `Process.argv` を追加する流れぽいのかな
    * [Implement Process.argv by byroot · Pull Request #11370 · ruby/ruby](https://github.com/ruby/ruby/pull/11370)


## [[Feature #20770] A *new* pipe operator proposal](https://bugs.ruby-lang.org/issues/20770)

* パイプライン演算子を追加する提案
* 例えば以下のようなコードの場合

```ruby
value = half(square(add(value, 3)))
```

* `#then` を使うと以下のように記述できる

```ruby
value = value.then { add(_1, 3) }.then { square(_1) }.then { half(_1) }
```

* これをパイプライン演算子 `|>` を用いて簡略的に書きたいという提案

```ruby
value = add(value, 3) |> square(_1) |> half(_1)
```

* いわゆるよくある？パイプライン演算子？ですね？
* 議論は盛り上がっているんですが個人的に Ruby だとオブジェクトをレシーバとしてメソッドを呼び出すことが殆どで `g(f(x))` みたいな関数っぽく処理を呼び出すコードを書くことはあんまりないのでそこまで有用には見えないんですよねえ
    * とはいえ、まったくないわけではないので局所的に便利になるところはなくはない
* 発展する流れとしては `.then{}` を `.{}` と簡略化する話もでてますね
    * `.call()` を `.()` と簡略化できるのと同じ粒度で

```ruby
client_api_url
  .then { URI.parse(it) }
  .then { Net::HTTP.get(it) }
  .then { JSON.parse(it).fetch(important_key) }
```

* が以下のようにかけるイメージ

```ruby
client_api_url
  .{ URI.parse(it) }
  .{ Net::HTTP.get(it) }
  .{ JSON.parse(it).fetch(important_key) }
```

* ちなみにパイプライン演算子だとこう

```ruby
client_api_url
  |> URI.parse(it) 
  |> Net::HTTP.get(it) 
  |> JSON.parse(it).fetch(important_key) 
```

* 上記のコードだときれいそうに見えるけど `g(f(x))` が `x. { f(_1) }.{ g(_1) }` みたいになるのはちょっとなんかイマイチに見える…





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



## [[Bug #20337] Complex#inspect mutates the string returned by `real.inspect`](https://bugs.ruby-lang.org/issues/20337)

* `Complex#inspect` が `real.inspect` の結果を書き換えているというバグ報告
* なので例えば `real.inspect` が `freeze` されているとエラーになる

```ruby
class Numeric
  def inspect = super.freeze
end

real = Numeric.new

# error: can't modify frozen String: "#<Numeric:0x000073b8613248e8>" (FrozenError)
Complex(real, 1).inspect
```

* このバグはすでに開発版の Ruby 3.4 では修正済みです
    * https://github.com/ruby/ruby/pull/11657



## [[Feature #20756] Introduce Boolean class](https://bugs.ruby-lang.org/issues/20756)

* `Boolean` クラスを追加する提案
* 雰囲気、以下のような感じ

```ruby
class TrueClass  < Boolean ; end
class FalseClass < Boolean ; end

# もしくは以下のようなハック
module Boolean ; end
TrueClass.include(Boolean);
FalseClass.include(Boolean);
```

* 要は `true` `false` を同じ型として扱いたいような要望ですね

```ruby
case(value)
when String  ...
when Integer ...
when true, false ... # Boolean かどうか
end
```

* これなんですが https://bugs.ruby-lang.org/issues/20756#note-4 に書かれている理由により Reject されています
    * `Boolean` で共通処理がなかったり、入れたとしても `#kind_of?` を使ってチェックするだけでそれはダックタイピングの原則にそってなよね、っていうのはそれはそうよねえ




## [[Feature #20742] Trying to assign to a variable in statement modifier should emit a warning](https://bugs.ruby-lang.org/issues/20742)

* 次のように後置if の条件式で代入した変数を左辺で参照すると実行時エラーになることがあります

```ruby
p a if a = 0.zero? # raises NameError “undefined local variable or method ‘a’”.
```

* これは事前に変数 `a` が定義されている場合ではエラーになりません

```ruby
a = nil
p a if a = 0.zero? # no error
```

* このような挙動の違いがあるので後置if で代入式を書いた場合は警告を出すようにするチケットです、多分
* これなんですがそもそもなんでエラーになるのかって話をすると Ruby のパーサーの評価順の問題になります

```ruby
p a if a = 0.zero?
```

* 上記のコードではまず `p a` がパースされます
* このときにパーサでは `a` は『メソッド』として認識されます
* 次に `if a = 0.zero?` が評価されて『 `a` の変数が定義されている』と認識されます
* その上で実際にコードが実行されると `p a` を評価するときに『 `a` はメソッドなのでメソッドを呼び出そうとする。しかし、 `a` メソッドはないので `NameError` になる』という挙動になります
* なので `a` メソッドが定義されている場合は問題なく動作します

```ruby
def a = 42

# p a は変数ではなくてメソッドの a を呼び出す
p a if a = 0.zero?
# => 42
```

* 逆にいうと後置if でない場合は『先に if 式がパースされる』ので `a` 変数を参照します

```ruby
def a = 42

# 先に a = 0.zero? がパースされて『変数 a が存在している』という前提で後続のコードがパースされる
if a = 0.zero?
  # なのでここの a はメソッドではなくて変数を参照する
  p a
end
```

* この話は https://bugs.ruby-lang.org/issues/20742#note-6 に詳しくかいてあります
* で、元々のチケットの話なんですがこういうコードは標準ライブラリで使われているなど一般的なケースとコメントされていますね
    * https://bugs.ruby-lang.org/issues/20742#note-3
    * https://bugs.ruby-lang.org/issues/20742#note-4
* パッと見、代入した変数を左辺で参照しているというよりかは後続で参照しているみたいなことが多いんですかね？

```ruby
# lib/net/http.rb の一部のコードを抜粋

# ここで代入した opt は後続で参照している
arg.pop if opt = Hash.try_convert(arg[-1])

# ...

if opt
  if opt[:use_ssl]
    opt = {verify_mode: OpenSSL::SSL::VERIFY_PEER}.update(opt)
  end
end
```





------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Misc #20746] Request to migrate the json gem from flori/json repository to ruby/json](https://bugs.ruby-lang.org/issues/20746)

* json ライブラリのリポジトリを `flori/json` から `ruby/json` へ移動させるチケット
* 現状の json ライブラリのリポジトリは `flori` 配下にあり一部の Ruby コミッターの人がマージ権限など持っています
* ただ、ポジトリの管理権限は flori 氏のみが持っているらしくいくつか問題点がでているらしいです
    * 具体的には [Transfer request for `ruby/json` · Issue #591 · flori/json](https://github.com/flori/json/issues/591) に記述されています
* flori 氏がこのリポジトリに対して数年活動していなかったりコンタクトが取れない状態になってしまっているのでそれを解消するために ruby リポジトリへ移動させたいというのがこのチケットの旨
    * 氏の github みると他の活動自体はしているのですがコンタクトが取れない状態みたいですね
* てっきり ruby リポジトリの配下で管理されていると思っていたんですがそうじゃなかったのは以外



## [[Bug #20741] RubyVM::InstructionSequence.compile emits a wrong warning (prism?)](https://bugs.ruby-lang.org/issues/20741)

* 3.4-dev で `RubyVM::InstructionSequence.compile` で意図しない警告がでているというバグ報告

```shell
$ RBENV_VERSION=3.4-dev ruby -we 'p RubyVM::InstructionSequence.compile("42").eval'
<compiled>:1: warning: possibly useless use of a literal in void context
```

* これは `prism` 起因らしいですね
    * 開発版の Ruby はいまはデフォルトでは prism を使用するようになっているので
    * https://bugs.ruby-lang.org/issues/20741#note-1

```shell
$ RBENV_VERSION=3.4-dev ruby --parser=parse.y -we 'p RubyVM::InstructionSequence.compile("42").eval'
42
$ RBENV_VERSION=3.4-dev ruby --parser=prism -we 'p RubyVM::InstructionSequence.compile("42").eval'
<compiled>:1: warning: possibly useless use of a literal in void context
42
```

* ちなみに `warning: possibly useless use of a literal in void context` は『参照されてないリテラルがある』と出る警告です

```shell
$ RBENV_VERSION=3.3.4 ruby -we '42'
-e:1: warning: possibly useless use of a literal in void context
```

## [[Bug #20726] Issue with hash without braces when assigned to constant with ractor literals](https://bugs.ruby-lang.org/issues/20726)

* `shareable_constant_value: literal` のときに `[a: obj]` のようなコードがあると `compile error` になるというバグ報告

```ruby
# shareable_constant_value: literal
A = [a: 1]
p A
__END__
output:
-- raw disasm--------
   trace: 1
   0000 newarray             1                                           (   2)
   0002 putspecialobject     3                                           (   2)
*  0004 setconstant          :A                                          (   2)
   trace: 1
   0006 putself                                                          (   3)
   0007 opt_getconstant_path [:A]                                        (   3)
   0009 opt_send_without_block <calldata:p, 1>                           (   3)
   0011 leave                                                            (   3)
---------------------
test.rb:2: argument stack underflow (-1)
test.rb: compile error (SyntaxError)
```

* `[{a: 1}]` だと問題ないのと `Prism` のパーサーだと再現しなかったので `parse.y` 特有ぽいですかね？


## [[Bug #20725] Inconsistent handling of doubly-unbounded ranges in Range#overlap?](https://bugs.ruby-lang.org/issues/20725)

* `(nil..nil)` な `Range` に対して `#overlap?` に特定の値を渡したときに一貫性がないというバグ報告

```ruby
# これは true を返す
p (nil..nil).overlap?(nil..)   # => true
p (nil..nil).overlap?(3..)     # => true

# これは false を返す
p (nil..nil).overlap?(..3)   # => false
```

* このバグは開発版の Ruby 3.4 で修正済み


## [[Feature #13820] Add a nil coalescing operator](https://bugs.ruby-lang.org/issues/13820)

* 左辺が `nil` のときのみ右辺を評価する演算子を追加する提案
* `||` とは違って『 `nil` のみを対象とする』みたいなやつ
    * `||` は `nil` だけではなくて `false` も条件になるが `false` は除く演算子を追加する提案

```ruby
# これは || と同じ
a = 0     ?? 55 # = 0
a = nil   ?? 55 # = 55

# これは右辺を返す
a = false ?? 55 # = false
```

* モチベーションとしては `a = flag ?? true` などするときに `expr` が `false` の場合は `false` で評価したい、みたいなところですかねー
    * `||` だと左辺ではなくて右辺が返ってくる
* ただし Ruby の構文では `??` 自体は有効な構文ではあるんですよねえ
    * `?? => # "?"` となる
* 最近コメントされていたのでこのチケットに気づいたんですが Ruby 上で `nil` と `false` を区別したいケースがどれだけあるのか次第なんですかねー
    * https://bugs.ruby-lang.org/issues/13820#note-15
    * 実際に `&.` は `nil` と `false` を明確に区別している
* 個人的にめちゃくちゃほしいわけではないけどあれば普通に使いそう




## [[Feature #20707] Move `Time#xmlschema` into core](https://bugs.ruby-lang.org/issues/20707)

* `Time#xmlschema` を Ruby 本体に移動させるチケット
* `Time#xmlschema` は XSML の datetime として表現するための文字列に変換するメソッド
    * [Time#iso8601 (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/Time/i/xmlschema.html)
    * `Time#iso8601` の alias でもある
* 現状だと `Time#xmlschema` は time deafult gem で定義されており `Time#strftime` に依存している
* これを `Time#strftime` に依存せずに専用のコードに落とし込むことでパフォーマンスを向上させるのがこのチケットの目的
* 実際に検証結果が以下の通りなんですが約5倍ほど早くなっているみたいですね

```
compare-ruby: ruby 3.4.0dev (2024-08-29T13:11:40Z master 6b08a50a62) +YJIT [arm64-darwin23]
built-ruby: ruby 3.4.0dev (2024-08-30T13:17:32Z native-xmlschema 34041ff71f) +YJIT [arm64-darwin23]
warming up......

|                        |compare-ruby|built-ruby|
|:-----------------------|-----------:|---------:|
|time._xmlschema         |      1.087M|    5.190M|
|                        |           -|     4.78x|
|utc_time._xmlschema     |      1.464M|    6.848M|
|                        |           -|     4.68x|
|time._xmlschema(6)      |    859.960k|    4.646M|
|                        |           -|     5.40x|
|utc_time._xmlschema(6)  |      1.080M|    5.917M|
|                        |           -|     5.48x|
|time._xmlschema(9)      |    893.909k|    4.668M|
|                        |           -|     5.22x|
|utc_time._xmlschema(9)  |      1.056M|    5.707M|
|                        |           -|     5.40x|
```

* この対応はすでに開発版の Ruby 3.4 に取り込み済みです
* あと細かいんですが `Time#iso8601` って `require "time"` しないと使えなかったんですが今回の対応により本体に組み込まれたので `require` せずに利用できるようになりました





## [[Bug #20716] Different instance_method behavior in Ruby 2.7 and Ruby 3.x](https://bugs.ruby-lang.org/issues/20716)

* Ruby 2.7 と Ruby 3.x で `instance_method` の挙動が異なっているというバグ報告
* 最初に提示されていたのは以下のようなコード

```ruby
module A
  def test(*args)
    super
  end
end

module B
  def test(a)
    puts a
  end
end

B.prepend(A)

class C
  include B
end

# この呼び出しは問題ない
B.instance_method(:test).bind(C.new).call(1)
# Ruby 2.7: 1
# Ruby 3.0: 1
# Ruby 3.1: 1

# lambda で B#test を再定義すると意図しないエラーになる
a = lambda do
  puts 'lambda'
end

B.module_exec do
  define_method(:test, a)
end

B.instance_method(:test).bind(C.new).call
# Ruby 2.7: lambda
# Ruby 3.0: wrong number of arguments (given 0, expected 1) (ArgumentError)
# Ruby 3.1: wrong number of arguments (given 0, expected 1) (ArgumentError)
```

* `define_method(:test, a)` したときになにか意図しない動作になっているんですかね？
* 実際には `instance_method` というよりかは `super` のキャッシュのバグらしい
    * https://bugs.ruby-lang.org/issues/20716#note-1
* なので `define_method` や `instance_method` を使用しない以下のコードで再現するらしい
    * https://bugs.ruby-lang.org/issues/20716#note-3
    * 特定の mixin を行っている際に `super` を呼び出した後に異なるシグネチャのメソッドを定義すると再現するみたい

```ruby
module A
  def test(*args)
    super
  end
end

module B
  def test(a)
    puts a
  end
end

class C; end

B.prepend(A)
C.include(B)

# ここで super のシグネチャがキャッシュされている
# メソッドを上書きする前に呼ばれなければ再現しない
C.new.test 1

module B
  def test
    puts 'lambda'
  end
end

C.new.test
```

* Ruby 3.0 から再現してたんですが今まで報告がなかったんですねー
* 修正PR はすでに作成されています
    * [Fix method caching bug when including/prepend module A that prepends module B by jeremyevans · Pull Request #11582 · ruby/ruby](https://github.com/ruby/ruby/pull/11582)




## [[Feature #9779] Add Module#descendants](https://bugs.ruby-lang.org/issues/9779)

* 任意のクラスやモジュールがどのクラスに継承されていたり mixin されているのかを取得する `Module#descendants` を追加する提案

```ruby
class X
end

class Y < X
end

class Z < Y
end

p X.descendants    #=> [X, Y, Z]

module A
end

module B
  include A
end

module C
  include A
end

p A.descendants    #=> [A, C, B]
```

* `Class#descendants` は [ActiveSupport で拡張されているメソッド](https://railsguides.jp/active_support_core_extensions.html#descendants) ですね
* また数年前に Ruby 本体にも入る予定だったんですがいろいろとあり、そっちは対応されませんでした
    * 参照: [[Feature #14394] Class.descendants](https://bugs.ruby-lang.org/issues/14394)
* また `Module#descendants` の方は ActiveSupport にも同等の機能は存在していないです
* `Module#descendants` 相当の機能が欲しくて調べていたらこのチケットを見つけたんですがチケット自体は10年以上前のもので特に進展などないので特に需要なさそうなんですかねえ







## [[Feature #20712] module should return newly defined module](https://bugs.ruby-lang.org/issues/20712)

* `module` の構文の戻り値を『その module のオブジェクトを返すようにする』提案

```ruby
# 以下のように自身を返すようにする
module M
end
# 現状 => nil
# 提案 => M
```

* モチベーションとしては `module の定義 + using` を一緒に行う際に効率がよい、という点ですね

```ruby
# 現状だと1度モジュールを定義したり Module.new したりする必要がある
using(Module.new {
  refine String do
    # ...
  end
})

module ArrayEx
  refine Array do
    # ...
  end
end
using ArrayEx
```

* これなんですが起票者は『module は `nil` を返すので module に返すようにする』という認識だったんですが実際には module は『最後に書いた式の結果』を返すようになっています

```ruby
result = module M
  # この結果を返す
  1 + 2
end

pp result # => 3
```

* なので次のように `self` を最後に返すことで元々やりたかったことも実現できます

```ruby
using(module M
  refine Array do
    def hoge = "hoge"
  end

  # 最後に self を返す
  self
end
)

pp [].hoge # => "hoge"
```

* と、いうことでこのチケットは close されてます



------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Feature #20702] Add `Array#fetch_values`](https://bugs.ruby-lang.org/issues/20702)

* `Array#fetch_values` を追加する提案
* モチベーションとしては `Array` と `Hash` は要素を取得するいずれかのメソッドが存在しています

```ruby
array = [1, 2, 3]
hash = { a: 1, b: 2, c: 3 }

# キーから値を取得する
pp array[1]   # => 2
pp array[4]   # => nil
pp hash[:a]   # => 1
pp hash[:d]   # => nil

# 見つからなければ例外を排出したりブロックを呼び出す
pp array.fetch(2)          # => 2
# pp array.fetch(4)          # => IndexError
pp array.fetch(4) { 42 }   # => 42
pp hash.fetch(:b)          # => 2
# pp hash.fetch(:d)          # => KeyError
pp hash.fetch(:d) { 42 }   # => 42

# 複数の値を取得する
pp array.values_at(1, 2)    # => [2, 3]
pp array.values_at(2, 3)    # => [3, nil]
pp hash.values_at(:b, :c)   # => [2, 3]
pp hash.values_at(:c, :d)   # => [3, nil]
```

* ただし `Hash` には『複数の値を取得しつつ見つからなければ例外を発生させる』メソッドとして `#fetch_values` があるんですが `Array` にはありません

```ruby
hash = { a: 1, b: 2, c: 3 }

pp hash.fetch_values(:c, :d)   # => KeyError
```

* なので `Array#fetch_values` も追加しよう、みたいな感じです
* `Hash#fetch_values` は使ったことないんですが `Array#fetch_values` も使いどころありそうなのかな
    * `Hash#fetch_values` が追加されたチケットは [Feature #10017: Add `Hash#fetch_values`](https://bugs.ruby-lang.org/issues/10017)





## [[Feature #20705] Should "0.E-9" be a valid float value?](https://bugs.ruby-lang.org/issues/20705)

* `0.E-9` のような指数の E表記を Ruby で有効な float 値として扱うかどうかのチケット

```ruby
# これは有効なフォーマット
pp Float("0.0E-9")
# => 0.0

# .0 の 0 がないとエラーになる
pp Float("0.E-9")
# => error: invalid value for Float(): "0.E-9" (ArgumentError)
```

* 元々は [[Ruby] Cannot work with zero-value Decimals · Issue #43877 · apache/arrow](https://github.com/apache/arrow/issues/43877) から発生した事象らしい
* チケットのコメントを見ると PostgreSQL や MySQL などの RDBMS では対応されているらしいですね？
* 指数表記的にはこれって有効なフォーマットになるんですかね？
    * [JISX0210:1986 情報交換用文字列による数値表現](https://kikakurui.com/x0/X0210-1986-01.html) の5ページ目を見ると一応有効なフォーマットになるのかな？





## [[Feature #20703] Alias StringIO#string to StringIO#to_s](https://bugs.ruby-lang.org/issues/20703)

* `StringIO#string` の alias として `StringIO#to_s` を追加したいという要望
* これ、 `StringIO` を使うときに保存されている文字列を取得する場合毎回 `#string` に変換するのが手間だったので `#to_s` が生えているといろいろと捗りそうですねー
* 例えば `puts` や式展開で都度 `string` を呼び出す必要がなくなります

```ruby
require "stringio"

my_sio = StringIO.new('my string')

# 現状
puts "value: #{my_sio}" # value: #<StringIO:0x0000764bba88eec0>

# 対応後
puts "value: #{my_sio}" # value: my string
```

* 直接 `#to_s` を呼んでいる場合は非互換な挙動になるんですがまあ流石に依存しているコードはないと思いたい…




## [[Bug #20701] Hash argument passed as keyword splat can be mutated inside method](https://bugs.ruby-lang.org/issues/20701)

* 通常 `**` で Hash オブジェクトの値は書き換わらないようになっています

def foo(a, h)
  # ここで h の値を書き変える
  h[:splat_modified] = true
end

b = { splat_modified: false }
# ** で渡した場合は b の値は変わらない
foo(1, **b)
pp b
# => {:splat_modified=>false}
```


* しかし、次のように特定のケースでメソッドに渡した場合に Hash オブジェクトの値が意図せず書き換わってしまうというバグ報告

```ruby
def foo(a, h)
  h[:splat_modified] = true
end

b = { splat_modified: false }
# * と位置引数と ** で引数を渡す
# a = 2
# h = b
# となる
foo(*[], 2, **b)

# b の値が書き換わってしまう
pp b
# => {:splat_modified=>true}
```

```ruby
# ** で受け取る場合も同様の挙動になる
def foo(a, **h)
  h[:splat_modified] = true
end

b = { splat_modified: false }
foo(*[], 2, **b)

pp b
# => {:splat_modified=>true}
```

* この不具合は開発版の Ruby 3.4 ですでに修正済み



## [[Bug #20653] Memory leak in String#start_with? when regexp times out](https://bugs.ruby-lang.org/issues/20653)

* `String#start_with?` で正規表現のタイムアウトが発生したときにメモリリークしているというバグ報告

```ruby
regex = Regexp.new("^#{"(a*)" * 10_000}x$", timeout: 0.000001)
str = "a" * 1000000 + "x"

10.times do
  100.times do
    # #start_with? でタイムアウトしたときにメモリリークが発生する
    str.start_with?(regex)
  rescue
  end

  puts `ps -o rss= -p #{$$}`
end
__END__
output:
  37504
53248
68864
84736
100352
115968
131712
147456
163072
178816
```

* Onigmo の処理でタイムアウトしたかどうかのエラーハンドリングを追加して改善しているみたいです
    * https://github.com/ruby/ruby/pull/11247
* このバグは開発版の Ruby 3.4 で修正済みです



## [[Feature #20676] Pathnames aren't Comparable](https://bugs.ruby-lang.org/issues/20676)

* `Pathname` を比較可能にしたいというチケット
* モチベーションとしては

```ruby
Pathname("/a/b").to_s <= Pathname("/a/b/c").to_s
```

* を

```ruby
Pathname("/a/b") <= Pathname("/a/b/c")
```

* と書きたいとのこと
* これなんですが `Pathname#<=>` はすでに定義されているので `include Comparable` すればシュッと実現できるんですね
    * 一緒に出されていた PR もそれをしているだけ
    * [Make Pathname comparable by gmcgibbon · Pull Request #40 · ruby/pathname](https://github.com/ruby/pathname/pull/40)

```ruby
require "pathname"

class Pathname
  include Comparable
end

pp Pathname("/a/b") <= Pathname("/a/b/c")
# => true
```

* ただ、これなんですが `Pathname#<=>` では単にパスを文字列として比較しているだけなので厳密にはディレクトリ構成に依存しない形での比較になります
    * [Pathname#<=> (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/Pathname/i/=3c=3d=3e.html)

```ruby
require "pathname"

class Pathname
  include Comparable
end

# /a/c は /a/b のサブディレクトリではないが true を返す
# これは Pathname("/a/b").to_s <= Pathname("/a/c").to_s と等価
pp Pathname("/a/b") <= Pathname("/a/c")
# => true
```

* これを満たす場合は `#start_with?` を利用するほうがいいんじゃないか、みたいなコメントもされてますね
    * https://bugs.ruby-lang.org/issues/20676#note-3

```ruby
# これは String#start_with? を使った場合を想定
(Pathname("/a/b/c").to_s+"/").start_with?(Pathname("/a/b").to_s+"/")
```

* このチケット自体は Feedback という形で閉じられています



## [[Bug #20697] `Rational("1r")` fails while `Complex("1i")` succeeds](https://bugs.ruby-lang.org/issues/20697)

* `Complex("1i")` は成功するが `Rational("1r")` は失敗するというバグ報告

```ruby
# error: invalid value for convert(): "1r" (ArgumentError)
Rational("1r")
```

* リテラルとして定義されている場合に失敗するんですね
    * `Float("1.2e-3")` は成功した
* これはエラーにならないような修正PR がでてます
    * https://github.com/ruby/ruby/pull/11447



## [[Feature #20692] Rewrite Array#bsearch in Ruby](https://bugs.ruby-lang.org/issues/20692)

* `Array#bsearch` を Ruby で書き直す提案
* 具体的な実装はチケットに書いてあります
* YJIT 環境だとこっちのほうが早いんですかねー
* チケットに載ってるベンチマークは以下の通り
    * `1/4` ぐらいになっているのかな

```
ruby 3.3.3 (2024-06-12 revision f1c7b6f435) +YJIT [x86_64-linux]

Benchmark results (average over 10000000 iterations):
                           user     system      total        real
Original bsearch:     12.329160   0.009148  12.338308 ( 12.337310)
Native bsearch:        3.437350   0.000057   3.437407 (  3.437270)
```


## [[Bug #20681] Regular expression warnings are treated as compiler warnings during runtime](https://bugs.ruby-lang.org/issues/20681)

* 次のような正規表現を定義すると警告が出力されます

```ruby
source = "/\w**/"
# warning: regular expression has redundant nested repeat operator '*': /\/w**\//
Regexp.new(source)
```

* これを次のように `#warn` で抑制するようにしたいんですが意図する挙動にならないという内容のチケットになります

```ruby
# 内部で警告が呼びされるときにこのメソッドが呼び出されることを想定しているが呼び出されない
def warn(...)
  puts "CALLED"
end

source = "/\w**/"
Regexp.new(source)
```

* これなんですがコメントにも書いてある通りトップレベルの `#warn` ではなくて `Warning.warn` の方を再定義する必要があります

```ruby
module Warning
  def warn(...)
    puts "CALLED"
  end
end

source = "/\w**/"
Regexp.new(source)
```



## [[Bug #20344] argument stack underflow (-1)](https://bugs.ruby-lang.org/issues/20344)

* 次のコードが Ruby 2.5 以降で `argument stack underflow (-1) (SyntaxError)` が発生するというバグ報告

```ruby
proc do
  next if true

  case nil
  when "a"
    next
  when "b"
  when "c"
    proc {}
  end

  next unless true
end
```

```
-- raw disasm--------
   trace: 100
   0000 nop                                                              (   1)
 <L000> [sp: 0]
   trace: 1
 <L004> [sp: 0]
   adjust: [label: 0]
   0001 putnil                                                           (   2)
   0002 leave                                                            (  13)
 <L008> [sp: 1]
   adjust: [label: 0]
   0003 putnil                                                           (   6)
   0004 leave                                                            (  13)
   adjust: [label: 8]
   0005 jump                 <L005>                                      (   5)
   0007 pop                                                              (   7)
   0008 jump                 <L005>                                      (   7)
*  0010 pop                                                              (   8)
   trace: 1
 <L011> [sp: -1]
   0011 putself                                                          (   9)
   0012 send                 <calldata:proc, 0>, nil                     (   9)
 <L012> [sp: -1]
   0015 pop                                                              (   9)
 <L005> [sp: 1]
   trace: 1
   0016 putnil                                                           (  12)
 <L001> [sp: -1]
   trace: 200
   0017 leave                                                            (  13)
---------------------
test.rb: 
test.rb:8: argument stack underflow (-1) (SyntaxError)
```

* 1行でもかけると再現しなくなるんですがどういう不具合なんだこれ
* このバグは開発版の Ruby 3.4 ですでに修正済みです



## [[Bug #20675] Parse error with required kwargs and omitted parens](https://bugs.ruby-lang.org/issues/20675)

* 最初は mruby 起因の話なのですが CRuby では次のようにメソッド定義にカッコ`()` がない場合は次の行まで参照しないようになっています

```ruby
def foo arg:
  123
end
```

* は

```ruby
def foo(arg:)
  123
end
```

* のように解釈されます
    * ちなみに mruby 3.3.0 だと `def foo(arg: 123)` と解釈されるらしい
* これを踏まえた上で Hash の省略記法を想定した場合に

```ruby
k=25
f k:
  10
```

* のときには

```ruby
k=25
f(k: 10)
```

* のようにキーワードのラベルは改行を考慮したほうがいいのか無視したほうがいいのか、という旨のチケットになっている
    * matz がチケット立てている
* これ、Hash の省略記法が実装されたあとでも同じような話題が上がっていましたねー
    * [[Bug #18396] An unexpected "hash value omission" syntax error when without parentheses call expr follows](https://bugs.ruby-lang.org/issues/18396)
* どちらにしても改行を無視する場合は非互換になってしまうのでそのあたりどうするべきなのか、みたいな話にはなっていますね
* 個人的には改行は無視してくれたほうが変な混乱はないと思うんだけども実際に依存しているケースもあるらしいので難しそう


## [[Misc #20652] Memory allocation for gsub has increased from Ruby 2.7 to 3.3](https://bugs.ruby-lang.org/issues/20652)

* Ruby 2.7.7 から Ruby 3.3.1 にアップデートしたら `String#gsub` のメモリ割当が増加しているという報告
* 次のようなコードのときに `MatchData` 関連で増加しているとのこと

```ruby
s = "foo              "
s.gsub(/ (\s+)/) { " #{'&nbsp;' * Regexp.last_match(1).length}" }
```

* [Bug #17507: Regexp capture groups ignored sometimes in some multithreaded environments (possible race condition)](https://bugs.ruby-lang.org/issues/17507) の対応の副作用らしい
    * こっちはマルチスレッド環境で `MatchData` 関連で不具合が発生してたみたい
        * マルチスレッド環境なのに特定の条件で `$~` の値が共有オブジェクトになっている話ぽい？
            * https://bugs.ruby-lang.org/issues/20652#note-5
        * なのでマルチスレッド関係なく `$~` が同一にならないように対応した結果メモリが増加しているみたい
* 以下のように正規表現のオプションで `MatchData` の生成を制御したりする案や [#17507](https://bugs.ruby-lang.org/issues/17507) の別対応をするかどうかなど議論されてます

```ruby
case str
when /^a/
  p $~ # => #<MatchData "a">
when /^b/c   # c オプションがある場合は MatchData を内部で生成しない
  p $~ # => nil
end
```




## [[Bug #20671] Do not show "unused block" warning on `send`](https://bugs.ruby-lang.org/issues/20671)

* Ruby 3.4 で対応予定の『ブロック引数を利用していないメソッドにブロック引数を渡す対応』の話です
* 元々は `send` でメソッドを呼び出した場合にも対応していたんですがフレームワークによっては呼び出すメソッドがブロックを受け入れるかどうか難しいため無効にするとのこと
* 実際に以下のような `test/unit` だと意図せず警告が出るらしいですね

```ruby
require 'test/unit'

class T < Test::Unit::TestCase
  def setup
  end

  def test_foo = nil
end

#=> /home/ko1/ruby/install/master/lib/ruby/gems/3.4.0+0/gems/test-unit-3.6.2/lib/test/unit/fixture.rb:284: warning: the block passed to 'priority_setup' defined at /home/ko1/ruby/install/master/lib/ruby/gems/3.4.0+0/gems/test-unit-3.6.2/lib/test/unit/priority.rb:183 may be ignored
```

* これはすでに開発版の Ruby 3.4 に取り込み済み
* ちなみに `public_send` は依然として警告が出ます

```ruby
class X
  def hoge
  end
end

x = X.new

# no warning
x.send(:hoge) {}

# warning: the block passed to 'X#hoge' defined at test.rb:2 may be ignored
x.public_send(:hoge) {}
```


## [[Feature #19840] [Proposal] Expand Find pattern to Multiple Find](https://bugs.ruby-lang.org/issues/19840)

* 次のように共通のデータ構造を持つ `Hash` の配列があるときにその `Hash` の要素を一括でパターンマッチで利用できるようにする提案

```ruby
# 以下のようなデータ構造のときに id や name などを一括でパターンマッチの対象として扱いした
{ results: [{ id: 1, name: "foo" }, { id: 2, name: "bar" }, ... ] }
```

* チケット内では具体的に以下のようなコードが提示されています

```ruby
# ids で各配列内の id の要素を取得する
case { results: [{ id: 1, name: "foo" }, { id: 2, name: "bar" }] }
in results: [*{ id: ids }]
  "matched: #{ids}"
else
  "not matched"
end
#=> matched: [1, 2]

# * がある場合は前方で id がある要素のみ取得する
case { results: [{ id: 1, name: "foo" }, { id: 2, name: "bar" }] }
in results: [*{ id: ids }, *]
  "matched: #{ids}"
else
  "not matched"
end
#=> matched: [1, 2]

# * がない場合は全てに id の要素がある必要がある
# なので以下の場合はマッチしない
case { results: [{ name: "foo" }, { id: 2, name: "bar" }] }
in results: [*{ id: ids }]
  "matched: #{ids}"
else
  "not matched"
end
#=> not matched
```

* `ids = results.map { _1[:id] }` みたいな抽出を安全に行いたい場合に便利なんですかね？
* 確かにこういうコードはよく書く気がするのであると便利そうな気はする
* ただ、開発者側的には同意しないとのこと
    * https://bugs.ruby-lang.org/issues/19840#note-3
    * パターンマッチの前身である [pattern-match gen](https://github.com/k-tsj/pattern-match) で実装したが利用頻度よりも仕様や実装の複雑さが上回るとのこと



## [[Bug #20649] Ripper fails to tokenize `def f; (x)::A =`](https://bugs.ruby-lang.org/issues/20649)

* `Ripper.tokenize` に `def f; (x)::A =` を渡すと Ripper 内部でエラーになるというバグ報告

```ruby
require "ripper"

# error: `on_error2': undefined method `pos' for nil (NoMethodError)
pp Ripper.tokenize 'def f; (x)::A ='
```

* `x::A` だとエラーにならないので `()` がついているのが原因ぽいですかね？
* これは開発版の Ruby 3.4 だとすでに修正済みです

```ruby
require "ripper"

pp Ripper.tokenize 'def f; (x)::A ='
# Ruby 3.3 => error: `on_error2': undefined method `pos' for nil (NoMethodError)
# Ruby 3.4 => ["def", " ", "f", ";", " ", "(", "x", ")", "::", "A", " ", "="]
```



## [[Feature #20669] Add Marshal::MarshalError class to differentiate ArgumentErrors](https://bugs.ruby-lang.org/issues/20669)

* `marshal` はいろんなデータをファイル（文字列）に変換し、そのデータを復元するためのライブラリ

```ruby
# データを文字列に変換
data = Marshal.dump({ id: 1, name: "homu", age: 14 })
pp data
# => "\x04\b{\b:\aidi\x06:\tnameI\"\thomu\x06:\x06ET:\bagei\x13"

# そのデータを復元する
pp Marshal.load(data)
# => {:id=>1, :name=>"homu", :age=>14}
```

* このときに `Marshal.load` にフォーマットが不正なデータや破損したデータを渡すと次のように `TypeError` や `ArgumentError` が発生する

```ruby
begin
  # 復元できるフォーマットではない場合
  Marshal.load("foobar")
rescue
  pp $!
  # => #<TypeError:"incompatible marshal file format (can't be read)\n\tformat version 4.8 required; 102.111 given">
end

begin
  # データが途中で破損している場合
  Marshal.load(Marshal.dump(Object.new).slice(0, 10))
rescue
  pp $!
  # => #<ArgumentError: marshal data too short>
end

begin
  # 以下のように MyThing に依存するようなデータを復元する場合
  # MyThing = Struct.new(:name, :age)
  # Marshal.dump(MyThing.new("Alice", 20))
  # => "\x04\bS:\fMyThing\a:\tnameI\"\nAlice\x06:\x06ET:\bagei\x19"
  Marshal.load "\x04\bS:\fMyThing\a:\tnameI\"\nAlice\x06:\x06ET:\bagei\x19"
rescue
  pp $!
  # => #<ArgumentError: undefined class/module MyThing>
end
```

* `TypeError` や `ArgumentError` は通常以下のような場合に発生することを期待するが `Marshal.load` の場合はそれ以外でも同エラーが発生するのでそれを区別できるようにしたい、というのがこのチケットの内容
    * `TypeError` : 引数の型が異なる場合
    * `ArgumentError` : 引数の数が異なる場合
* これを回避するために `Marshal::LoadError` を追加する提案が書かれている
    * `Marshal` の内部でエラーが発生した場合はこの例外を返す想定
* この提案の問題として互換性の話が上がっています
    * いままで `ArgumentError` だったものが `Marshal::LoadError` に変わるので `rescue ArgumentError` している箇所が非互換になってしまう
* これに限らず `ArgumentError` とするのかは難しそうですねえ



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Misc #20509] Document importance of #to_ary and #to_hash for Array#== and Hash#==](https://bugs.ruby-lang.org/issues/20509)

* `Array#==(other)` では `other` の定義によって挙動が変わるのでそれを明文化したいというチケット
* どう挙動が変わるのかというと `other.to_ary` と `other.==` が定義されている場合に依存します
* どういうことかというと `[1, 2, 3] == other` のときに『 `other.to_ary` メソッドが定義されていれば `other == [1, 2, 3]` を呼び出す』という挙動になります
* 例えば `other.==` が定義されているだけではそのメソッドは特に呼び出されません

```ruby
class X
  # このメソッドは呼び出されない
  def ==(other)
    pp "X#==(#{other})"
    [1, 2, 3] == other
  end
end

x = X.new
pp [1, 2, 3] == x
# => false
```

* しかし `other.to_ary` が定義されている場合は `other.==([1, 2, 3])` メソッドが呼び出されて、その結果が返ってきます

```ruby
class X
  # to_ary メソッドが定義されていればこのメソッドが呼び出されてその結果が変えてくる
  def ==(other)
    pp "X#==(#{other})"
    [1, 2, 3] == other
  end

  # このメソッドは実際には呼び出されない
  def to_ary(other)
    pp "X#to_ary(#{other})"
    []
  end
end

x = X.new
pp [1, 2, 3] == x
# => true

__END__
output:
"X#==([1, 2, 3])"
true
```

* ただし `#to_ary` は『メソッドが定義されているかどうかの判定』に使われているだけなので実際にメソッドは呼び出されません
* 逆にいうと `#to_ary` が定義されているだけで `Array` との比較は行われないことになります

```ruby
class X
  def to_ary
    [1, 2, 3]
  end
end

x = X.new

# [1, 2, 3] == x は #to_ary を内部で呼び出すとかはない
pp [1, 2, 3] == x          # => false
pp [1, 2, 3] == x.to_ary   # => true
```

* `#to_ary` を定義した上で `Array#==(other)` でも動くようにする場合は以下のように定義する必要があります

```ruby
class X
  # to_ary の結果と比較するような演算子を定義する
  def ==(other)
    to_ary == other
  end

  def to_ary
    [1, 2, 3]
  end
end

x = X.new

pp [1, 2, 3] == x          # => true
pp [1, 2, 3] == x.to_ary   # => true
```

* この挙動は `Array#==` だけではなくて `Hash#==` も同様の挙動になっています
* なぜこういう挙動になっているのかの背景は以下のコメントに詳しく書いてあります
    * https://bugs.ruby-lang.org/issues/20509#note-3
    * CRuby の実装的に対象のオブジェクトが『配列かどうか』を内部で判定するときに『 `#to_ary` が定義されていれば配列オブジェクトとして扱う』みたいな感じになっているらしい
        * いわゆるダックタイピング的な呼び出しを行うための機構
        * なので `#to_ary` の結果は関係ない




## [[Feature #20664] Add `before` and `until` options to Enumerator.produce](https://bugs.ruby-lang.org/issues/20664)

* `Enumerator.produce` に `before:` と `until:` のオプション（キーワード引数）を追加する提案
* `before:` と `until:` はどちらも『条件に当てはまるまでイテレーションを続ける』という挙動になるんですが以下のような違いがあります
    * `before:`: 条件に当てはまった値は含めない
    * `untile:`: 条件に当てはまった値は含める

```ruby
# superclass が nil になるまでイテレーションを続ける
# その値は含めない
enum = Enumerator.produce(File, before: :nil?, &:superclass)
enum.to_a #=> [File, IO, Object, BasicObject]

# pred が 0 になるまでイテレーションを続ける
# その値を含める
enum = Enumerator.produce(3, until: :zero?, &:pred)
enum_to_a #=> [3, 2, 1, 0]
```

* 上記の場合だと `before: / untile:` には判定メソッド名を渡すような形になっているんですが、 テストをみていると `Proc` オブジェクトも渡せるみたいですね
* これは [[Feature #20625] Object#chain_of](https://bugs.ruby-lang.org/issues/20625) から派生したチケットになります
* @[card](https://zenn.dev/mamayukawaii/articles/20240711081042)
* 判定条件にメソッド名を渡せるようになっているんですが Ruby 的に Symbol をそのままメソッド的に扱うことはないのでちょっと違和感がありますねー
    * Symbol をメソッドとして扱いたくない、みたいな話は昔聞いたことはある
    * 今回みたいに 1つのメソッドに対して複数の条件を指定したい、みたいなのってむずかしいんですよねえ…
* 機能としてはあるといいと思うんですがどういい感じにかけるといいのかはむずい




## [[Bug #20668] [3.3] shareable_constant_value: literal crash](https://bugs.ruby-lang.org/issues/20668)

* 以下のようなコードを実行すると `shareable_constant_value` 関連で Ruby がクラッシュするというバグ報告

```ruby
# shareable_constant_value: literal

FORM_STRATEGIES = {
  'product' => Object,
  'storefront_password' => String,
  'contact' => Class,
}
```

```
/tmp/vQ8KjQT/16: [BUG] Segmentation fault at 0x0000000f00000006
ruby 3.3.3 (2024-06-12 revision f1c7b6f435) [x86_64-linux]

-- Control frame information -----------------------------------------------
c:0001 p:0000 s:0003 E:0002c0 DUMMY  [FINISH]


-- Threading information ---------------------------------------------------
Total ractor count: 1
Ruby thread count for this ractor: 1

-- Machine register context ------------------------------------------------
 RIP: 0x0000768f705bb61f RBP: 0x000055c2bc4a9a38 RSP: 0x00007ffeb6846b90
 RAX: 0x0000768f54773d78 RBX: 0x000055c2bc4a59f0 RCX: 0x0000000000000000
 RDX: 0x0000000f00000006 RDI: 0x000055c2bc26c540 RSI: 0x000055c2bc26d300
  R8: 0x0000768f54773d78  R9: 0x000055c2bc4a9998 R10: 0x000055c2bc4a98e0
 R11: 0x000055c2bc4a98b8 R12: 0x000055c2bc320190 R13: 0x000055c2bc4a98c0
 R14: 0x00007ffeb6846c58 R15: 0x0000768f54773d78 EFL: 0x0000000000010206
...
```

* Ruby 3.2 や開発版の Ruby 3.4 では再現せずに Ruby 3 系でのみ再現するみたいでね
* 上記のコードだと `FORM_STRATEGIES` のいずれかの値を削除したりクラスオブジェクトじゃない場合はクラッシュしないのでエッジケースではあるのかなー



## [[Bug #19231] Integer#step and Float::INFINITY - inconsistent behaviour when called with and without a block](https://bugs.ruby-lang.org/issues/19231)

* `0.step(Float::INFINITY)` に対して値を取得するときに取得の仕方によって返ってくる値が異なるバグ報告
* `take` を経由して値を取得する場合は `Float` が返ってくる

```ruby
pp 0.step(Float::INFINITY).take(1)
# => [0.0]
```

* 一方でブロック引数で値を取得する場合は `Integer` が返ってくる

```ruby
pp 0.step(Float::INFINITY) { break _1 }
# => 0
```

* `#step` の引数が有限数だった場合は `Float` が返ってくる

```ruby
pp 0.step(100.0).take(1)
# => [0.0]

pp 0.step(100.0) { break _1 }
# => 0.0
```

* また `#first` の場合は以下のような挙動になる

```ruby
# 無限の場合も有限の場合も Integer を返す
pp 0.step(Float::INFINITY).first   # => 0
pp 0.step(100.0).first             # => 0

# 引数がある場合は Float を返す
pp 0.step(Float::INFINITY).first(1)   # => [0.0]
pp 0.step(100.0).first(1)             # => [0.0]
```

* 以下のようにバージョンによっていろいろと変わっているみたいですね
    * `0.step(Float::INFINITY, 10).each` の場合
        * Ruby ~ 2.0: `Float`
        * Ruby 2.1 ~ 2.5: `Integer`
        * Ruby 2.6 ~ : `Float`
    * `0.step(Float::INFINITY, 10) { ... }` の場合
        * Ruby ~ 2.0: `Float`
        * Ruby 2.1 ~ : `Integer`
    * https://bugs.ruby-lang.org/issues/19231#note-2
* https://github.com/nobu/ruby/commit/332a08f5d4e4b5c3fcb0b7e73b19628ac61f37a8#diff-212d624c3bd338cf8a8bec98ebf2104f045759a47f8aba63a213db97f30eed22 の修正だと `Integer` に統一されている
    * これはまだマージされてない


## [[Feature #20525] Percent string literal with indentation support or String#dedent](https://bugs.ruby-lang.org/issues/20525)

* インデントをサポートする %記法や `String#dedent` メソッドを追加する提案
* 例えば以下のようなヒアドキュメントを書いたときに

```ruby
ContentSlide(title: "Why Phlex?"){
  Markdown <<~MARKDOWN

  * Because its fun
  * Because its super-de-dooper
  MARKDOWN
},
```

* `Markdown` の名前が重複しているので以下のように `{}` で書きたいのがモチベーションみたいですね
* 例えば %記法だと以下のような感じでかけて

```ruby
ContentSlide(title: "Why Phlex?"){
  Markdown %~{
    # Why do you like markdown?

    * Because its fun
    * Because its super-de-dooper
  }
},
```

* `String#dedent` だと以下のようにかけるイメージです

```ruby
ContentSlide(title: "Why Phlex?"){
  Markdown %{
    # Why do you like markdown?

    * Because its fun
    * Because its super-de-dooper
  }.dedent
},
```

* これに対して %記法の方は以下のコードと競合するとコメントされていますね
    * https://bugs.ruby-lang.org/issues/20525#note-4

```ruby
# 以下は現在でも有効な %記法
# ~ から ~ までが文字列として定義される
pp %~{~
# => "{"
```

* また `<<~"}"` を使う書き方もコメントされていますね
    * https://bugs.ruby-lang.org/issues/20525

```ruby
ContentSlide(title: "Why Phlex?"){
  Markdown <<~"}"

  * Because its fun
  * Because its super-de-dooper
  }
},
```

* 個人的には `{}` の方が見栄えはいいんですがヒアドキュメントの識別子を `EOS` で一貫しているのでそこまで気にはならないすねえ
* `String#dedent` はそれはそれでよさそうな気がしたんですが入れるとしたら `<<~` 以外のケースでどれだけ利用するケースがあるのか、ってところになりそうですかねー



## [[Feature #20657] Allow Enumerable#map(&:method) and #each accept additional parameters for method](https://bugs.ruby-lang.org/issues/20657)

* ブロック引数の後に位置引数を渡せるようにする提案
* 以下のようなブロック引数内で引数を渡すようなコードを

```ruby
c = a.map { |item| item.ljust(10) }
# or
a.each { |item| item.some_method(arg1, arg2) }
```

* 以下のように `map(&シンボル, 位置引数)` みたいな形で書きたいとのこと

```ruby
c = a.map(&:ljust, 10)
# or
a.each(&:some_method, arg1, arg2)
```

* 構文的には以下のチケットと同じ提案ですかね？
* @[card](https://zenn.dev/mamayukawaii/articles/20240321203840)
* これに関して matz もコメントしているんですが『 `ljust(10)` に渡す引数は `#map` のメソッド呼び出しではなくて `ljust` のメソッドに属しているわけではない』とのこと
    * https://bugs.ruby-lang.org/issues/20657#note-2
* この手の機能提案は定期的に上がるんですが Numbered parameters は使いたくないんですかね〜〜〜
* 変にトリッキーな構文を入れるよりも以下のように書いたほうがわかりやすいと思うんですが

```ruby
c = a.map { _1.ljust(10) }
# or
a.each { _1.some_method(arg1, arg2) }
```




## [[Bug #20654] Floor and ceil have unexpected behaviour when ndigits is large](https://bugs.ruby-lang.org/issues/20654)

* `Integer` や `Float` の `#ceil` や `#floor` に大きい値を渡すと意図しない値が返ってくるバグ報告
* 例えば以下のように負の値を渡すと逆に桁数が増えるような挙動になっている

```ruby
puts -1.floor(-5)    # => -100000
puts -1.floor(-10)   # => -10000000000

puts 1.ceil(-5)    # => 100000
puts 1.ceil(-10)   # => 10000000000
```

* このときに `-20` を渡すと `0` が返ってくるというバグ報告

```ruby
puts -1.floor(-20)   # => 0
puts 1.ceil(-20)     # => 0
```

* 修正PR はすでに出されてます
    * https://github.com/ruby/ruby/pull/11257






## [[Bug #20651] `false && (1 in 1)` produces argument stack underflow (-1)](https://bugs.ruby-lang.org/issues/20651)

* `false && (1 in 1)` や `false || (1 in 1)` を実行すると `argument stack underflow` が発生するというバグ報告

```ruby
false && (1 in 1)
```

```
-- raw disasm--------
   trace: 1
   0000 putobject            false                                       (   1)
   0002 leave                                                            (   1)
 <L004> [sp: 1]
 <L002> [sp: 1]
   0003 pop                                                              (   1)
*  0004 pop                                                              (   1)
   0005 putobject            false                                       (   1)
   0007 leave                                                            (   1)
---------------------
test.rb:1: argument stack underflow (-1)
test.rb: compile error (SyntaxError)
```

* このバグは Ruby 3.0 から発生しているみたいですね


## [[Bug #20623] Unexpected behavior of blocks in Enumerator::Lazy#zip](https://bugs.ruby-lang.org/issues/20623)

* 以下のように `lazy` を `zip` したときの挙動が異なるというバグ報告

```ruby
# lazy しない場合
pp [1].zip([2]).map { _1 }
# => [[1, 2]]

# Enumerator::Lazy#zip 経由で map した場合
pp [1].lazy.zip([2].lazy).map { _1 }.force
# => [1]

pp [1].lazy.zip([2].lazy).force.map { _1 }
# => [[1, 2]]
```

* `lazy` した後に `map` した場合は `1` になるんですが `force` したあとに `map` すると `[1, 2]` になります
* 期待する挙動としては `[1, 2]` になりそうですね
* この不具合はすでに修正済みで以下のようになります

```ruby
# Enumerator::Lazy#zip 経由で map した場合
pp [1].lazy.zip([2].lazy).map { _1 }.force
# Ruby 3.3 => [1]
# Ruby 3.4 => [[1, 2]]
```

* バグ修正なので Ruby 3.3.x の安定版でリリースされるかも？


-------------------------------------------------------------------------------------------------------------------------------------------------



## [[Misc #20575] Syntax Moratorium til 3.4](https://bugs.ruby-lang.org/issues/20575)

* いま Ruby のパーサがいろいろと開発されているので Ruby 3.4 までは新しい構文の変更はしませんよー、というアナウンス
    * ただし、バグ修正は対象外
* なので Ruby 3.4 では新しい構文とかは入る予定はなさそう
* ところで Syntax Moratorium って一般的な専門用語だったりするんですかね？


## [[Bug #20647] Invalid return in class/module body from within singleton class](https://bugs.ruby-lang.org/issues/20647)

* 以下のように `class` 定義内で `return` するとシンタックスエラーになる

```ruby
class X
  # error: Invalid return in class/module body (SyntaxError)
  return
end
```

* しかし、特異クラスの場合はシンタックスエラーではなくて `LocalJumpError` になるというバグ報告

```ruby
class << Object
  # error: unexpected return (LocalJumpError)
  return
end
```

* この不具合は開発版の Ruby 3.4 では修正済み

```ruby
class << Object
  # Ruby 3.3 => error: unexpected return (LocalJumpError)
  # Ruby 3.4 => error: Invalid return in class/module body (SyntaxError)
  return
end
```





## [[Bug #20640] Evaluation Order Issue in f(**h, &h.delete(key))](https://bugs.ruby-lang.org/issues/20640)

* Ruby 3.0 からキーワード引数で Hash を渡しつつブロック引数で `Hash#delete` を呼び出したときの評価順が壊れているというバグ報告
* 以下のように `**hass` しつつ `&hash.delete` すると Ruby 3.0 から挙動が変わります

```ruby
def check(**kwd, &block)
  kwd
end

kwd = { a: proc {} }

# kwd をキーワード引数で渡しつつ、ブロック引数で #delete した値を渡す
# Ruby 3.0 以降では delete した後の値が kwd に渡される
pp check(**kwd, &kwd.delete(:a))
# Ruby 3.0 以前 => {:a=>#<Proc:0x00007c0154fa8f58 /tmp/vrD7Av9/27:6>}
# Ruby 3.0 以降 => {}
```

* また位置引数がある場合は Ruby 3.3 から挙動が変わります

```ruby
def check(*args, **kwd, &block)
  kwd
end

args = []
kwd = { a: proc {} }

# こっちは位置引数も渡す
pp check(*args, **kwd, &kwd.delete(:a))
# Ruby 3.3 以前 => {:a=>#<Proc:0x00007c0154fa8f58 /tmp/vrD7Av9/27:6>}
# Ruby 3.3 以降 => {}
```

* Ruby では `*` `**` する前に値をコピーして渡すのが期待する挙動なので以前と同じような挙動になるように修正される予定
    * 修正PR: https://github.com/ruby/ruby/pull/11206

```ruby
def check(*args, **kwd, &block)
  kwd
end

kwd = { a: proc {} }

# 以下が期待する挙動になる
pp check(**kwd, &kwd.delete(:a))
# {:a=>#<Proc:0x00007c0154fa8f58 /tmp/vrD7Av9/27:6>}


args = []
kwd = { a: proc {} }

# こっちは位置引数も渡す
pp check(*args, **kwd, &kwd.delete(:a))
# {:a=>#<Proc:0x00007c0154fa8f58 /tmp/vrD7Av9/27:6>}
```


## [[Bug #20643] Ruby 3.2 behavior change for protected and private methods when yield self](https://bugs.ruby-lang.org/issues/20643)

* 以下のコードが Ruby 3.2 から挙動が変わったというバグ報告

```ruby
class Foo
  def try
    yield self
  end

  private

  def bar
    "private method bar called"
  end
end

# 内部では :bar.to_proc.call(Foo.new) が呼び出される
pp Foo.new.try(&:bar)
# Ruby 3.1 => "private method bar called"
# Ruby 3.2 => error: private method `bar' called for an instance of Foo (NoMethodError)
```

* これは [[Bug #18826] Symbol#to_proc inconsistent, sometimes calls private methods](https://bugs.ruby-lang.org/issues/18826) の影響で意図する変更になります
* #18826 は `Symbol#to_proc` で `private` や `protected` なメソッドも呼び出せるというバグ報告で Ruby 3.1 では以下のように動作していました

```ruby
class X
  private

  def foo
    "foo"
  end
end

# X.new.foo が呼び出される
pp :foo.to_proc.call(X.new)
# => "foo"
```

* しかし `:foo.to_proc` の期待する動作は `lambda { |t| t.foo }` であり、このときに `private` や `protected` メソッドが呼ばれるのはおかしい、ということで Ruby 3.2 で修正されました 

```ruby
class X
  private

  def foo
    "foo"
  end
end

# X.new.foo が呼び出される
pp :foo.to_proc.call(X.new)
# Ruby 3.1 => "foo"
# Ruby 3.2 => error: private method `foo' called for #<X:0x00007149b83a8e50> (NoMethodError)
```

* そういえばこういう修正があったなーと思い出したんですが `NEWS` には特に載ってなかったんですね
* バグ修正ではあるけど非互換な変更ではあるので注意したい


-----------------------------------------------------------------------------------------------------------------


## [[Bug #20637] SyntaxError class definition in method body can be bypassed](https://bugs.ruby-lang.org/issues/20637)

* クラスやモジュールはメソッド定義の中で定義しようとするとエラーになる

```ruby
def hoge
  # error: class definition in method body (SyntaxError)
  class X; end
end
```

* しかし、以下のように `class <<` ではエラーにならない

```ruby
def hoge
  class << Object.new
    # no error
    class  X; end
  end
end

hoge
```

* `def` だとクラスを定義するスコープが不明なんですが `class <<` の場合は定義するスコープが明確なのでそういう違いがあるんですかねー



## [[Feature #17279] Allow a negative step in Range#step with a block](https://bugs.ruby-lang.org/issues/17279)

* `Range#step` に負の値を渡すと以下のような挙動になる

```ruby
# 2 ずつ減っていく
pp (10..1).step(-2).to_a
# => [10, 8, 6, 4, 2]
```

* このときに負の値 + ブロック引数を渡すとエラーになる

```ruby
(10..1).step(-2) { p _1 }
```

* これを許容するようにするチケット
* これは以下のチケットで対応したときに緩和されるとのこと
    * https://bugs.ruby-lang.org/issues/17279#note-2


## [[Feature #18368] Range#step semantics for non-Numeric ranges](https://bugs.ruby-lang.org/issues/18368)

* `Range#step` の挙動を調整するチケット
* 現状の実装だと「 `#succ` で begin を N 回進めて、結果を返す」という挙動になっている
* それを「begin + step で繰り返して結果を返す」という挙動に変えたいというのがチケットの内容
* 要は `Range#step` の挙動を調整し、以下のようなコードを動かせるようにするのがチケットの目的

```ruby
# 1日ずつ加算して配列に変換したい
# いまはこれができない
(Time.parse('2021-12-01')..Time.parse('2021-12-24')).step(1.day).to_a
```

* 最終的には互換性を保ちつつ `+` でも繰り返すようにされる予定

```ruby
# 以下のようなコードが動くようになる
p ('a'..).step('a').take(3)
# => ["a", "aa", "aaa"]

p (Time.now..).step(24*60*60).take(3)
# => [2023-03-04 12:16:52.546531817 +0200,
#     2023-03-05 12:16:52.546531817 +0200,
#     2023-03-06 12:16:52.546531817 +0200]
```

* また、いくつか挙動が調整されており、以下のように `#step` に負の値 + ブロックを渡したときにエラーにならなくなりました

```ruby
# これは Ruby 3.3 でも PR でも変わらない
p (1..-10).step(-3).to_a
# => [1, -2, -5, -8]

# これは元々エラーになっていたが動くようになる
(1..-10).step(-3) { p _1 }
# Ruby 3.3 => step can't be negative (ArgumentError) -- inconsistent with ArithmeticSequence behavior
# PR       => 1, -2, -5, -8
```

* また、以下のように float が絡む場合の挙動も変わる

```ruby
require 'active_support/all'

p (1.0..).step(2.minutes).take(3)
# Ruby 3.3 => [1.0, 121.0, 241.0] -- これは内部で #to_f が呼ばれて、その値が加算される
# PR       => [1.0, 2 minutes and 1.0 second, 4 minutes and 1.0 second] -- これは #coerce で適切に変換されるようになった
```

* 上記であげたように実装自体はされており、いまは PR のレビュー中って感じですね
    * https://github.com/ruby/ruby/pull/7444




## [[Bug #20620] singleton_method undefined for module using "extend self"](https://bugs.ruby-lang.org/issues/20620)

* 以下のように `extend self` したときに `self` のメソッドが `.singleton_method` で取得することができないバグ報告
* 通常は以下のようにクラスメソッドが定義されている場合は `.singleton_method` でクラスメソッドのオブジェクトを取得することができます

```ruby
class Klass
  def self.foo
  end
end

p Klass.singleton_methods
# => [:foo]

p Klass.singleton_method(:foo)
# => #<Method: Klass.foo() singleton_method.rb:2>
```

* しかし、以下のように自身を `extend` した場合にうまく取得することができないとのこと

```ruby
module ExtendSelf
  extend self

  def foo
  end
end

p ExtendSelf.singleton_methods
# => [:foo]

# error: `singleton_method': undefined singleton method `foo' for `ExtendSelf' (NameError)
p ExtendSelf.singleton_method(:foo)
```

* これなんですが `.singleton_method` は『特異クラスに定義されているメソッドを返す』ことになります
* なので前者の `Klass.singleton_method(:foo)` は `.foo` が特異クラスにメソッドが定義されているので問題ありません
* しかし、後者の `ExtendSelf.singleton_method(:foo)` は `.foo` が特異クラスではなくて『継承リストのモジュール内で定義されている』ので厳密にいうと特異メソッドとしては扱われない感じですかね
* また `.singleton_methods` に関しては引数がない場合は『継承した特異メソッドも含む』になるので `ExtendSelf.singleton_methods` に `:foo` が含まれます
* ただし `.singleton_methods(false)` にすることで『継承した特異メソッドを含まない』になり `:foo` が含まれなくなります

```ruby
module ExtendSelf
  extend self

  def foo
  end
end

# こっちは継承した特異メソッドを含む
p ExtendSelf.singleton_methods
# => [:foo]

# こっちは継承した特異メソッドを含まない
p ExtendSelf.singleton_methods(false)
# => []
```

* なのでこれ自体はバグではないとのこと
    * https://bugs.ruby-lang.org/issues/20620#note-1



## [[Feature #20625] Object#chain_of](https://bugs.ruby-lang.org/issues/20625)

* 次のように要素が連鎖しているツリーやリストのような構造をたどるようなことはある

```ruby
# ファイルシステムの構造を指定してファイルやディレクトリを取得する
def breadcrumbs(root)
  crumbs = []
  current = root

  while current
    crumbs << current
    current = current.parent_dir
  end

  crumbs
end
```

* このような走査を行う `Object#chain_of` メソッドを追加する提案

```ruby
class Object
  def chain_of(&block)
    chain = []
    current = self

    while current
      chain << current
      current = block.call(current)
    end

    chain
  end
end
```

* これを利用すると以下のようなリンク構造を走査することができる

```ruby
class ListNode
  attr_accessor :value, :parent

  def initialize(value, parent = nil)
    @value = value
    @parent = parent
  end

  def ancestors
    chain_of(&:parent).tap(&:shift)
  end
end

root = ListNode.new("root")
child1 = ListNode.new("child1", root)
child2 = ListNode.new("child2", child1)

# pp child2.ancestors.map(&:value)
# => ["child1", "root"]
```

* 要は『ブロックが次の要素を返して、それが `nil` になるまで走査を繰り返す』みたいな挙動になる感じですね
    * 今回でいうと『 `#parent` が `nil` になるまで繰り返す』みたいな挙動になる
* この挙動に近いのが `Enumerator.produce` でこっちは『ブロックを呼び出し続ける』みたいな挙動になる感じですね
    * https://docs.ruby-lang.org/ja/latest/method/Enumerator/s/produce.html
* 個人的には便利なケースもありそうだなあ、と思いつつ `Object` に直接生やしちゃうのはやや過剰な気がする
* ちなみに `Enumerator.produce` を利用すると以下のように記述することはできます

```ruby
pp Enumerator.produce(child2) { _1.parent or raise StopIteration }.map(&:value)
# => ["child2", "child1", "root"]
```

* `raise StopIteration` の部分がやや冗長なので以下のように `Enumerator` にメソッドを追加してもいいのかも

```ruby
class Enumerator
  def self.chain_of(initial = nil, &block)
    produce(initial) { block.call(_1) or raise StopIteration }
  end
end

pp Enumerator.chain_of(child2, &:parent).map(&:value)
# => ["child2", "child1", "root"]
```

* 個人的には `Enumerator` に定義する方が好み



## [[Bug #20617] /\pArabic/ character property doesn't match certain Arabic characters](https://bugs.ruby-lang.org/issues/20617)

* 正規表現の Unicode プロパティの `\p{Arabic}` が一部のアラビア文字にマッチしていないというバグ報告

```ruby
str = "شغل مرحلة أولى ، جداً؟"

# \p{Arabic} にマッチしない文字がいくつか存在する
# スペース, カンマ, クエッション, fatahan
p str.chars.reject {|char| /\p{Arabic}/.match(char)}.uniq
# => [" ", "،", "ً", "؟"]
```

* これは `Arabic` というプロパティは `用字(scripts)` を対象としており `一般句読点(Punction)` は含まれないのでこういう挙動になるらしい
    * https://bugs.ruby-lang.org/issues/20617#note-1
    * Unicode にはこの2つの概念があるぽい
* 両方とも含めるようにする場合は `ブロック(block)` を参照する `In_Arabic` を利用することができるらしい

```ruby
str = "شغل مرحلة أولى ، جداً؟"

# スペースだけ該当しない
p str.chars.reject {|char| /\p{In_Arabic}/.match(char)}.uniq
# => [" "]
```

* 更に `In_Arabic` だけでは不十分な可能性もあり、他の `block` も指定する必要があるとのこと
    * https://bugs.ruby-lang.org/issues/20617#note-2
    * https://www.unicode.org/Public/15.1.0/ucd/Blocks.txt

```ruby
/\p{In_Arabic}|\p{In_Arabic_Extended_A}|\p{In_Arabic_Extended_B}|\p{In_Arabic_Extended_C}|\p{In_Arabic_Mathematical_Alphabetic_Symbols}|\p{In_Arabic_Presentation_Forms_A}|\p{In_Arabic_Presentation_Forms_B}|\p{In_Arabic_Supplement}/
```

* Unicode むずかしい…



## [[Bug #20607] Exception messages are inconsistent when thread-local variables are accessed](https://bugs.ruby-lang.org/issues/20607)

* スレッドローカルの情報にアクセスするメソッドのエラーメッセージに一貫性がないバグ報告
* 以下の場合は `123 is not a symbol (TypeError)` のようなエラーメッセージが出力される

```ruby
t = Thread.new {}.join

t.thread_variable_set(123, 42)   # error: 123 is not a symbol (TypeError)
t.thread_variable?(123)          # error: 123 is not a symbol (TypeError)
t.thread_variable_get(123)       # error: 123 is not a symbol (TypeError)
t[123] = 42                      # error: 123 is not a symbol (TypeError)
```

* 一方で以下は `123 is not a symbol nor a string (TypeError)` とエラーになる

```ruby
t = Thread.new {}.join

t.fetch(123)   # error: 123 is not a symbol nor a string (TypeError)
t.key?(123)    # error: 123 is not a symbol nor a string (TypeError)
t[123]         # error: 123 is not a symbol nor a string (TypeError)
```

* 前者は `string` の文言がなくて後者は `string` の文言がついてる違いですね
* 厳密に言えば `string` も渡すことができるので後者の方が正しそう
* これを対応する PR はでています
    * https://github.com/ruby/ruby/pull/11097




## [[Bug #20606] Thread#thread_variable_get, Thread#thread_variable? and Thread#[] methods handle non-String/Symbol parameter values differently](https://bugs.ruby-lang.org/issues/20606)

* 次のようにスレッドが保持する情報に対してアクセスするメソッドがいくつかある

```ruby
t = Thread.new {}.join

# こっちはスレッドローカル変数
t.thread_variable_set(:a, 42)
p t.thread_variable?(:a)      # => false
p t.thread_variable_get(:a)   # => nil

# こっちはスレッド固有の情報
t[:a] = "hoge"
p t[:a]   # => "hoge"
```

* このときに文字列や Symbol 以外で値を参照しようとしたときの挙動が異なるというバグ報告

```ruby
t = Thread.new {}.join

# こっちは例外にならずに値を返す
p t.thread_variable?(123)      # => false
p t.thread_variable_get(123)   # => nil

# こっちは例外になる
# error: `[]': 123 is not a symbol nor a string (TypeError)
t[123]
```

* ただし、スレッドローカル変数が設定されている場合は `#thread_variable?` `#thread_variable_get` も `TypeError` が発生します

```ruby
t = Thread.new {}.join

t.thread_variable_set(:a, 42)

# 何かしら変数が設定されている場合は以下2つもエラーになる
# error: 123 is not a symbol (TypeError)
p t.thread_variable?(123)
p t.thread_variable_get(123)
```

* これは Ruby 3.4 では `#thread_variable?` `#thread_variable_get` も `TypeError` が発生するように修正されました


## [[Bug #20604] Performance regression in C++ extensions due to lack of optimization flags by default since Ruby 2.7](https://bugs.ruby-lang.org/issues/20604)

* Ruby 2.7 から C++ 拡張の最適化が効いてないというバグ報告
    * sassc gem のパフォーマンスが劣化しているのを調べていたら `-O3` の最適化が効いていないことを見つけたみたい
    * 10倍以上遅くなっているとのこと
* これは Ruby 本体が、っていうよりかは C++ で拡張機能を利用したときの話になりそうですかねー
* 他にも影響がある gem とかあるのかな


## [[Feature #20580] Pipe Operator accepting lambda](https://bugs.ruby-lang.org/issues/20580)

* Ruby にいわゆるパイプライン演算子を追加する提案
* 以下のように記述すると左から順に `Proc` を適用していくようなイメージ

```ruby
add_one = -> a { a + 1 }
add_two = -> a { a + 2 }

# add_two.call(add_one.call(2)) と等価
2 |> add_one |> add_two == 5
```

* これ系は前提として『メソッドがシュッとオブジェクトとして変換できる』場合じゃないとなかなか成り立たない気がする
    * そもそも `Proc` オブジェクト自体を多様することは殆どないので上記のようなコードは遊ぶときぐらいしか利用できないと思う
* コメントでも書かれているんですがメソッドをオブジェクトとして利用する場合は以下のように記述する必要があるのでイマイチなんですよねえ

```ruby
2 |> &obj.method(:whatever)
```

* 逆にいうと『メソッドをシュッとオブジェクトに変換できる』構文とかがあれば利用できそうではありそうかなあ



## [[Bug #20593] `Kernel#format` emits a `too many arguments for format string` warning when called with a single hash and no key is used](https://bugs.ruby-lang.org/issues/20593)

* 以下のように `Kernel#format` に位置引数を渡したときにその値が使用されていない場合に警告がでます

```ruby
$VERBOSE = true

# warning: too many arguments for format string
format("%s", 1, 2)
```

* ただし、キーワード引数の場合は警告はでない
    * バグの可能性が低いかららしい？
    * 位置引数と違って『意図しない値』を渡す可能性が低いかららしい

```ruby
$VERBOSE = true

# no warning
format("%{a}s", a: 1, unused: 2)
```

* しかし、次のように『キーワード引数が1つも使われいない場合』には警告がでてくるというバグ報告

```ruby
$VERBOSE = true

# warning: too many arguments for format string
format("test", unused: 2)
```

* 上記の場合は『警告がでないこと』を期待するみたいですね
    * PR: https://github.com/ruby/ruby/pull/11053
* 個人的には警告を出すようにしちゃったほうが一貫性がある気がするんですが、ノイズになるんですかねー




## [[Feature #20594] A new String method to append bytes while preserving encoding](https://bugs.ruby-lang.org/issues/20594)

* エンコーディングを維持しながらバイト列を追加する `String#byteconcat` メソッドの提案
* `profobuf` や `MessagePack` などのバイナリプロトコルを利用する場合に以下のようにシリアライズする

```ruby
Post = Struct.new(:title, :body) do
  def serialize(buf)
    buf <<
    255 << title.bytesize << title <<
    255 << body.bytesize << body
  end
end

Post.new("Hello", "World").serialize("somedata".b)
# => "somedata\xFF\x05Hello\xFF\x05World" #<Encoding:ASCII-8BIT>
```

* このときに問題になるのが `Encoding::ASCII_8BIT` に対して `UTF-8` などの文字列を結合しようとした場合にエラーになる

```ruby
Post.new("H€llo", "Wôrld").serialize("somedata".b)
# => incompatible character encodings: ASCII-8BIT and UTF-8 (Encoding::CompatibilityError)
```

* こういう問題を回避するためにバイト列単位で結合する `String#byteconcat` を追加する提案

```ruby
class String
  def byteconcat(*strings)
    strings.map! do |s|
      if s.is_a?(String) && s.encoding != encoding
        s.dup.force_encoding(encoding)
      else
        s
      end
    end
    concat(*strings)
  end
end

Post = Struct.new(:title, :body) do
  def serialize(buf)
    buf.byteconcat(
      255, title.bytesize, title,
      255, body.bytesize, body,
    )
  end
end

Post.new("H€llo", "Wôrld").serialize("somedata".b)
# => "somedata\xFF\aH\xE2\x82\xACllo\xFF\x06W\xC3\xB4rld" #<Encoding:ASCII-8BIT>
```

* これ系のデータってそもそも `String` で扱うべきなんですかねー


## [[Bug #20597] `eval('break if false')` should raise SyntaxError but retuns nil](https://bugs.ruby-lang.org/issues/20597)

* `break if false` を実行すると `SyntaxError` になる

```ruby
# Invalid break (SyntaxError)
break if false
```

* しかし `eval` で同コードを実行したときには `SyntaxError` にならないというバグ報告

```ruby
# no error
eval("break if false")
```

* チケットの内容によると以下のように一部の書き方だと `SyntaxError` になるみたいですね

```ruby
eval('break if false') #=> nil
eval('break if (false)') #=> nil
eval('break if nil') #=> nil
eval('break if (nil)') #=> Can't escape from eval with break (SyntaxError)
eval('break if 0>1') #=> Can't escape from eval with break (SyntaxError)
```

* また `next` `redo` も同様のこと





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Bug #20505] Reassigning the block argument in method body keeps old block when calling super with implicit arguments](https://bugs.ruby-lang.org/issues/20505)

* 次のように `super` を呼び出す前にブロック引数の値を変えたときに意図しない挙動になるバグ報告

```ruby
class A
  def positional_arg(a)
    puts a
  end

  def block_arg(&block)
    yield
  end
end

class B < A
  def positional_arg(a = nil)
    a = 'b'
    # これは親メソッドに書き換えた a の値が渡される
    super
  end

  def block_arg(&block)
    block = proc { puts 'b' }
    # このときに書き換えた block の値が親メソッドに渡されない
    super
  end
end

B.new.positional_arg('a')      # => b
B.new.positional_arg           # => b
B.new.block_arg { puts 'a' }   # => a
B.new.block_arg                # => error: no block given (yield) (LocalJumpError)
```

* これ自体は『現状そういう挙動になっています』以上の話ではないみたいですね
    * `super` 自体がかなり特殊な動きになっている
* 同様に `super()` も『ブロック引数を委譲する』という挙動になります
    * https://bugs.ruby-lang.org/issues/20505#note-3

```ruby
class A
  def foo
    yield
  end
end

class B < A
  def foo
    # 親メソッドにブロック引数が委譲される
    super()
  end
end

B.new.foo { puts "Hello" } #=> Hello
```

* そういえば Ruby やりはじめたときに `super` でいろいろとハマった記憶を思い出した



## [[Bug #20592] Interrupting Addrinfo causes Segmentation fault on alpine](https://bugs.ruby-lang.org/issues/20592)

* ruby:3.4.0-preview1 と alpine 3.20 の組み合わせで以下のコードが segv するというバグ報告

```ruby
# test.rb

require 'socket'
require 'timeout'

begin
  Addrinfo.ip("1234.example.com")
rescue StandardError => e
  puts e
end

sleep 10 # wait getaddrinfo to resolve and fail
```

```shell
/app # ruby test.rb
execution expired
[BUG] Segmentation fault at 0x0000000000000028
ruby 3.4.0preview1 (2024-05-16 master 9d69619623) [x86_64-linux-musl]

-- Machine register context ------------------------------------------------
 RIP: 0x00007fefe4cd4886 RBP: 0x0000000000000001 RSP: 0x00007fefc95d3a10
 RAX: 0x0000000000000001 RBX: 0x00007fefc94212e0 RCX: 0x00007fefc95d0b70
 RDX: 0x0000000000000010 RDI: 0x0000000000000000 RSI: 0x00007fefc95d08f0
  R8: 0x0000000000000000  R9: 0x0000000000000000 R10: 0x0000000000000000
 R11: 0x0000000000000217 R12: 0x00007fefc9421340 R13: 0x00007fff5a0ec750
 R14: 0x00007fefe4649b10 R15: 0x00007fefc95d3b38 EFL: 0x0000000000010202

-- Other runtime information -----------------------------------------------
```

* 内部の実装として `Addrinfo` を解放するときに `freeaddrinfo` 関数を使っているんですが alpine だとその関数に `NULL` を渡すとエラーになるらしい
* 対応PR自体はでてますね
    * https://github.com/ruby/ruby/pull/11045



## [[Feature #20564] Switch default parser to Prism](https://bugs.ruby-lang.org/issues/20564)

* Ruby の master ブランチのデフォルトのパーサーを prism にするチケット
* Ruby 3.4 のデフォルトパーサーとして問題ないかどうかを検証するのが目的
* matz 的にも現状のテストがすべてパスしていればデフォルトにして検証する事自体は賛成みたいですね
    * https://bugs.ruby-lang.org/issues/20564#note-4
* 2024/06/22 時点ではまだ適用されてはなさそう



------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Bug #20586] Some filesystem calls in dir.c are missing error handling and can return incorrect results if interrupted](https://bugs.ruby-lang.org/issues/20586)

* 特定の条件下で `Dir.glob` の戻り値が意図しない結果になっているというバグ報告
* 具体的には `datadog` のプロファイラを有効にしているとおかしくなるらしい
    * 報告者は `datadog` の開発者でそういう問い合わせがあったらしい
    * https://github.com/DataDog/dd-trace-rb/issues/3450

```
# プロファイラが無効なとき
irb(main):002:0> Dir.glob('/gcsfuse/t*')
 => ["/gcsfuse/test.html", "/gcsfuse/test.txt"]
```

```
# プロファイラが有効なとき
irb(main):002:0> Dir.glob('/gcsfuse/t*')
 => []
```

* 原因自体は `dir.c` の `dir_each_entry` でエラーハンドリングがうまくできてないのが要因ぽいみたいですね？
    * `READDIR` は『ディレクトリストリームの末尾に達した場合』に `NULL` を返すが、何らかの原因でエラーになった場合も `NULL` を返す
    * 今回の datadog のケースでは後者の『エラーが発生している状態』になっているがそこがハンドリングされていないので空の配列を返しているぽい

```c
static VALUE
dir_each_entry(VALUE dir, VALUE (*each)(VALUE, VALUE), VALUE arg, int children_only)
{
    struct dir_data *dirp;
    struct dirent *dp;
    IF_NORMALIZE_UTF8PATH(int norm_p);

    GetDIR(dir, dirp);
    rewinddir(dirp->dir);
    IF_NORMALIZE_UTF8PATH(norm_p = need_normalization(dirp->dir, RSTRING_PTR(dirp->path)));
	// ここでエラーが発生したときに errorno をみてエラーハンドリングしてないのが原因ぽい
    while ((dp = READDIR(dirp->dir, dirp->enc)) != NULL) {
      // ... do things
    }
    return dir;
}
```

* `datadog` 側の期待値としては『間違った値を返すのではなくて例外を発生してほしい』とのこと、それはそう
    * https://bugs.ruby-lang.org/issues/20586#note-3



## [[Bug #20582] Directory not empty](https://bugs.ruby-lang.org/issues/20582)

* macOS で `brew upgrade ruby` するとエラーになるバグ報告
    * `Error: Directory not empty @ dir_s_rmdir /private/tmp/xxx` になるらしい
    * 原因は `.DS_Store` が存在していること
* 以下の環境で発生したとのこと
    * Ruby Version: 3.3.3
    * Homebrew Version: Homebrew 4.3.5-118-g766b9b8
* いろいろと詳しく記載はされてはいるんですがそもそも Ruby の問題なのか Homebrew の問題なのかは明確になってないみたいですね
    * https://bugs.ruby-lang.org/issues/20582#note-1



## [[Feature #19001] Data: Add #to_h symmetric to constructor with keyword args [Follow-on to #16122 Data: simple immutable value object]](https://bugs.ruby-lang.org/issues/19001)

* `Data` クラスに `#to_h` を追加することで対称的に変換を行いたい要望
* どういうことかというと次のように一旦 Hash オブジェクトに変換した後に `Data` で定義したクラスに変換するようなイメージ

```ruby
Point = Data.define(:x, :y, :z)

points = [
  Point.new(x: 1, y: 0, z: 0),
  Point.new(x: 0, y: 1, z: 0),
  Point.new(x: 0, y: 0, z: 1),
]

# ここで一度 Hash オブジェクトにする
hashes = points.map(&:to_h)

# Hash オブジェクトから Point に戻す
points_2 = hashes.map { |h| Point.new(**h) }

points_2 == points
#=> true
```

* なんですがこれ自体はすでに実装済みで上記のコードはすでに動作するとのこと
    * https://bugs.ruby-lang.org/issues/19001#note-2
    * `#to_h` も実装済み

```ruby
Point = Data.define(:x, :y, :z)

points = [
  Point.new(x: 1, y: 0, z: 0),
  Point.new(x: 0, y: 1, z: 0),
  Point.new(x: 0, y: 0, z: 1),
]

hashes = points.map(&:to_h)
pp hashes
# => [{:x=>1, :y=>0, :z=>0}, {:x=>0, :y=>1, :z=>0}, {:x=>0, :y=>0, :z=>1}]
```

* と、いうことでこのチケットは閉じられています



## [[Bug #20573] Warning.warn shouldn't be called for disabled warnings](https://bugs.ruby-lang.org/issues/20573)

* `Warning#warn` は警告が出力されるタイミングで呼び出される Ruby のメソッド
    * [Warning#warn (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/Warning/i/warn.html)

```ruby
module Warning
  def self.warn(message, category:)
    pp category => message
  end
end

def get_var
  $=
end

get_var
# output: {:deprecated=>"/tmp/vlhK9hI/25:8: warning: variable $= is no longer effective\n"}
```

* カテゴリごとの警告は `Warning[]` で制御できるんですが『無効になっているときには `#warn` は呼び出されるべきではない』というバグ報告
* 現状は無効になっていても `Warning#warn` が呼び出される

```ruby
module Warning
  def self.warn(message, category:)
    pp category => message
  end
end

def get_var
  $=
end

# deprecated の警告は無効になっているが Warning.warn が呼び出される
pp Warning[:deprecated]   # => false
get_var
# output: {:deprecated=>"/tmp/vlhK9hI/25:8: warning: variable $= is no longer effective\n"}
```

* 開発版の Ruby 3.4 では無効になっている警告は `Warng#warn` が呼び出されないようになりました

```ruby
module Warning
  def self.warn(message, category:)
    pp category => message
  end
end

def get_var
  $=
end

# deprecated の警告が無効な場合は deprecated の Warning#warn は呼び出されない
pp Warning[:deprecated]   # => false
get_var
# Ruby 3.3 => output: {:deprecated=>"/tmp/vlhK9hI/25:8: warning: variable $= is no longer effective\n"}
# Ruby 3.4 => output: non

# deprecated の警告が有効な場合は deprecated の Warning#warn が呼び出される
Warning[:deprecated] = true
pp Warning[:deprecated]   # => true
get_var
# Ruby 3.3 => output: {:deprecated=>"/tmp/vlhK9hI/25:8: warning: variable $= is no longer effective\n"}
# Ruby 3.4 => output: {:deprecated=>"/tmp/vlhK9hI/25:8: warning: variable $= is no longer effective\n"}
```

* またこれによりパフォーマンスが向上するとのこと
    * https://github.com/ruby/ruby/pull/10960

```ruby
puts RUBY_DESCRIPTION

eval "def test; " +
  1000.times.map { "$=" }.join(";") + "; end"

def run_benchmark count
  i = 0
  while i < count
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    yield
    ms = Process.clock_gettime(Process::CLOCK_MONOTONIC) - start
    puts "itr ##{i}: #{(ms * 1000).to_i}ms"
    i += 1
  end
end

run_benchmark(25) do
  250.times do
    test
  end
end
```

```
ruby 3.3.3 (2024-06-12 revision f1c7b6f435) [x86_64-linux]
itr #0: 157ms
itr #1: 133ms
itr #2: 108ms
itr #3: 109ms
itr #4: 112ms
itr #5: 112ms
itr #6: 112ms
itr #7: 112ms
itr #8: 113ms
itr #9: 113ms
itr #10: 113ms
itr #11: 112ms
itr #12: 112ms
itr #13: 112ms
itr #14: 117ms
itr #15: 108ms
itr #16: 108ms
itr #17: 110ms
itr #18: 109ms
itr #19: 112ms
itr #20: 113ms
itr #21: 112ms
itr #22: 112ms
itr #23: 112ms
itr #24: 112ms
```

```
ruby 3.4.0dev (2024-06-15T20:14:58Z master ef423dd6d4) [x86_64-linux]
itr #0: 2ms
itr #1: 2ms
itr #2: 2ms
itr #3: 2ms
itr #4: 2ms
itr #5: 2ms
itr #6: 2ms
itr #7: 2ms
itr #8: 2ms
itr #9: 2ms
itr #10: 2ms
itr #11: 2ms
itr #12: 2ms
itr #13: 2ms
itr #14: 2ms
itr #15: 2ms
itr #16: 2ms
itr #17: 2ms
itr #18: 2ms
itr #19: 2ms
itr #20: 2ms
itr #21: 2ms
itr #22: 2ms
itr #23: 2ms
itr #24: 2ms
```




## [[Feature #20576] Add MatchData#bytebegin and MatchData#byteend](https://bugs.ruby-lang.org/issues/20576)

* バイト単位でのマッチした位置情報を返す `MatchData#bytebegin / byteend` メソッドを追加する提案
* 以下のようなイメージ

```ruby
result = /(\d+)年(\d+)月/.match("2021年1月")

# 既存の MatchData#begin / end は文字単位の位置を返す
# なので『月』でマッチした位置は以下のような文字の位置を返す
pp result.begin(2)   # => 5
pp result.end(2)     # => 6

# bytebegin / end はこれの byte 単位での位置情報を返す
pp result.bytebegin(2)   # => 7
pp result.byteend(2)     # => 8
```

* 現状でもバイト単位ので位置情報は `MatchData#byteoffset` で取得はできるけど先頭と終端をそれぞれ別々に取得する場合には個別のメソッドで定義されている方がパフォーマンスの改善にもつながるとのこと

```ruby
result = /(\d+)年(\d+)月/.match("2021年1月")

pp result.byteoffset(2)
# => [7, 8]
```

* matz 的には機能を追加する事自体には同意だけど `#bytebegin / byteend` の名前をどうするのかの話がでてますねー
    * https://bugs.ruby-lang.org/issues/20576#note-3




## [[Bug #20569] Instruction sequence generated from `shareable_constant_value: literal` files may not be serialized to binary](https://bugs.ruby-lang.org/issues/20569)

* 次のように `shareable_constant_value: literal` が含まれているコードを iseq からバイナリ化するとエラーになるバグ報告

```ruby
iseq = RubyVM::InstructionSequence.compile(<<~'RUBY')
  # shareable_constant_value: literal
  REGEXP = /#{}/
RUBY

# error: ibf_dump_object_unsupported: 0x00007d5cd224ade0 [3LM    ] T_ICLASS  (NotImplementedError)
iseq.to_binary
```

* これは開発版の Ruby 3.4 で修正済み
* また Ruby 3.3 系にもバックポートされています
    * Ruby 3.3.3 だと直ってそうですね


## [[Bug #20570] Nokey behavior changed since 3.3.](https://bugs.ruby-lang.org/issues/20570)

* 以下のようなコードで Ruby 3.3 から挙動が変わっているというバグ報告

```ruby
receiver_value = Set.new
method_name = :merge
args = [1]
kwargs = {}
block = nil

receiver_value.__send__(method_name, *args, **kwargs, &block)
# Ruby 3.2 => `do_with_enum': value must be enumerable (ArgumentError)
# Ruby 3.3 => no keywords accepted (ArgumentError)
```

* どういうことかというとコメントにわかりやすい例がかかれてました
    * https://bugs.ruby-lang.org/issues/20570#note-3

```ruby
def foo(*, **nil); :ok; end

foo(1, **{})    #=> Ruby 3.2: :ok
                #=> Ruby 3.3: :ok
foo(*[1], **{}) #=> Ruby 3.2: :ok
                #=> Ruby 3.3: no keywords accepted (ArgumentError)
```

* そもそも `no keywords accepted` がどういうエラーなのかっていうとメソッドのシグネチャが `**nil` になっている場合には『キーワード引数を渡せない』定義になるのでそのメソッドに対してキーワード引数を渡そうとするエラーですね

```ruby
def foo(**nil); :ok; end

# error: no keywords accepted (ArgumentError)
foo(key: 1)
```

* またこのときに `**{}` を渡した場合はエラーにはなりません

```ruby
def foo(**nil); :ok; end

# no error
foo(**{})
```

* なんですが Ruby 3.3 だと `foo(*[1], **{})` でエラーになるっていうバグですねー。
* このバグは開発版の Ruby 3.4 で修正済みです
    * https://github.com/ruby/ruby/commit/fc33559c40e08e4ae0a98821a679abddc4bb247c




-----------------------------------------------------------------------------------------------------------------------------------------------------------------



## [[Bug #20571] Compile error on for loop](https://bugs.ruby-lang.org/issues/20571)

* 以下のようなコードを実行するとコンパイルエラーになるというバグ報告

```ruby
for _ in 1.5 or _ in []
end
__END__
output:
-- raw disasm--------
   trace: 1
 <L000> [sp: 0, unremovable: 1, refcnt: 1]
   0000 putobject            1.5                                         (   1)
   0002 jump                 <L002>                                      (   1)
 <L006> [sp: 1, unremovable: 1, refcnt: 1]
 <L004> [sp: 1, unremovable: 0, refcnt: 0]
   0004 pop                                                              (   1)
*  0005 pop                                                              (   1)
   0006 putobject            false                                       (   1)
 <L002> [sp: 1, unremovable: 0, refcnt: 1]
   0008 send                 <calldata:each, 0>, nil                     (   1)
 <L001> [sp: -1, unremovable: 0, refcnt: 2]
   0011 leave                                                            (   1)
---------------------
test.rb:1: argument stack underflow (-1)
test.rb: compile error (SyntaxError)
```

* これ、各演算子（構文）の優先順位ってどういう扱いになるべきなんですかね…



## [[Feature #20415] Precompute literal String hash code during compilation](https://bugs.ruby-lang.org/issues/20415)

* 文字列リテラルの hash 値をコンパイル時に計算することで `Hash` へのアクセスを高速化するチケット
* これにより `hash["hoge"]` が `hash[:hoge]` のような Symbol でのアクセスと同等の速さにすることを目標としているらしい
* こういう高速化のアイディア面白いですよねーそして実際に開発版の Ruby 3.4 で取り込まれました
* 手元で試してみたら確かに高速化してた

```
ruby 3.3.2 (2024-05-30 revision e5a195edf6) [x86_64-linux]
Warming up --------------------------------------
              symbol     2.666M i/100ms
          dyn_symbol     2.781M i/100ms
           small_lit     2.366M i/100ms
          frozen_lit     2.274M i/100ms
Calculating -------------------------------------
              symbol     26.179M (± 0.8%) i/s -    133.279M in   5.091356s
          dyn_symbol     26.336M (± 1.0%) i/s -    133.485M in   5.069139s
           small_lit     23.766M (± 1.6%) i/s -    120.667M in   5.078672s
          frozen_lit     22.788M (± 0.9%) i/s -    115.979M in   5.089744s

Comparison:
              symbol: 26179265.3 i/s
          dyn_symbol: 26335757.4 i/s - same-ish: difference falls within error
           small_lit: 23765856.6 i/s - 1.10x  slower
          frozen_lit: 22788460.8 i/s - 1.15x  slower
```

```
ruby 3.4.0dev (2024-06-07T21:59:59Z master 0d91887c6a) [x86_64-linux]
Warming up --------------------------------------
              symbol     1.933M i/100ms
          dyn_symbol     1.926M i/100ms
           small_lit     1.936M i/100ms
          frozen_lit     1.929M i/100ms
Calculating -------------------------------------
              symbol     19.662M (± 2.1%) i/s -     98.563M in   5.015106s
          dyn_symbol     19.632M (± 2.5%) i/s -     98.226M in   5.006520s
           small_lit     19.386M (± 1.3%) i/s -     98.714M in   5.092814s
          frozen_lit     19.253M (± 1.7%) i/s -     96.426M in   5.009729s

Comparison:
              symbol: 19661821.9 i/s
          dyn_symbol: 19631729.0 i/s - same-ish: difference falls within error
           small_lit: 19386290.5 i/s - same-ish: difference falls within error
          frozen_lit: 19253290.4 i/s - same-ish: difference falls within error
```

* 実アプリケーションでも文字列リテラれるでアクセスすることはまあまあありそう




## [[Bug #18622] const_get still looks in Object, while lexical constant lookup no longer does](https://bugs.ruby-lang.org/issues/18622)

* 次のように `::` で定数参照した場合と `const_get` で定数参照した場合で差異があるというバグ報告

```ruby
module ConstantSpecsTwo
  Foo = :cs_two_foo
end

module ConstantSpecs
end

# これは定数参照できる
p ConstantSpecs.const_get("ConstantSpecsTwo::Foo") # => :cs_two_foo

# これはエラーになる
# error: const_get.rb:9:in `<main>': uninitialized constant ConstantSpecs::ConstantSpecsTwo (NameError)
p ConstantSpecs::ConstantSpecsTwo::Foo
```

* これは Ruby 2.5 で定数参照が変わった時に関連しているぽい

```ruby
class C
end

# トップレベルで定義された定数は暗黙的に Object の配下で定義される
class C2
end

# なので Ruby 2.4 以前では C:: で参照する事ができていたが Ruby 2.5 からはできなくなった
p C::C2
# Ruby 2.4 => C2
# Ruby 2.5 => error: `<main>': uninitialized constant C::C2 (NameError)
```

* 2年前のチケットなんですが、直接定数を参照したときのアクセスと矛盾しているが、互換性のためにこの挙動を維持するとのこと
    * https://bugs.ruby-lang.org/issues/18622#note-21




## [[Feature #20565] Relax formal argument at label](https://bugs.ruby-lang.org/issues/20565)

* `def foo(if:)` のような名前をキーワード引数で定義することができるなら `def foo(C:)` や `def foo($g:)` が定義できるのも許容できるようね？というチケット
* 今日って 4/1 だっけ？と思ったけどもう過ぎてた
* これ、どういうときに利用したいんですかね…？
* `if` とは違って `C` や `$g` は参照できるスコープが異なるので仮に許容された場合にはちゃめちゃにならないのか気になる…



## [[Bug #19749] Confirm correct behaviour when attaching private method with `#define_method`](https://bugs.ruby-lang.org/issues/19749)

* 次のように `private` メソッドを `#define_method` 経由で呼び出した時にエラーにならないのは期待する挙動かどうかの確認のチケット

```ruby
# これは private メソッドとして定義される
def bar; end


foo = Object.new
# private メソッドを public メソッドとして定義する
foo.singleton_class.send(:define_method, :bar, method(:bar))

# これはエラーになるのかならないのか
foo.bar # No error.
```

* 起因としては `TruffleRuby` だと上のコードがエラーになるらしい
    * https://github.com/oracle/truffleruby/issues/3134
* これは `#define_method` すると新しいメソッド定義しているだけなので可視化性は現在のスコープに依存するとのこと
    * なので次のような定義だと `private` になる

```ruby
def bar; end

foo = Object.new
foo.singleton_class.class_exec do
  private
  foo.singleton_class.send(:define_method, :bar, method(:bar))
end

# error: private method `bar' called for #<Object:0x000077436c728fb8> (NoMethodError)
foo.bar # NoMethodError
```

* 起票されていた内容自体は問題ないが、チケットの中で以下のような挙動が見つかる

```ruby
class A
  def a; end
  private def b; end

  m = instance_method(:b)
  define_method(:c, m) # public メソッドとして定義される
  define_method(:b, m) # これも public メソッドとして定義されることを期待するが private メソッドになる

  private

  m = instance_method(:a)
  define_method(:d, m) # private メソッドとして定義される
  define_method(:a, m) # これも private メソッドとして定義されることを期待するが public メソッドになる

  # [:c, :b] を期待するが [:c, :a] が返ってくる
  p public_instance_methods(false)  # => [:c, :a] # should be [:c, :b]

  # [:a, :d] を期待するが [:b, :d] が返ってくる
  p private_instance_methods(false) # => [:b, :d] # should be [:a, :d]
end
```

* 要するに同名で `define_method(:foo, instance_method(:foo))` を定義するときに可視化性も更新するかどうか、ってところがポイントですね
* 1年近く前のチケットだったんですが最終的には『可視化性を更新する』という形になったみたいです

```ruby
class C
  def foo; end

  private

  define_method(:foo, instance_method(:foo))
  p private_instance_methods(false)
  # Ruby 3.3 => []
  # Ruby 3.4 => [:foo]
end
```

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Bug #20516] The version of rexml in ruby 3.3.2 has not been updated since 3.2.6.](https://bugs.ruby-lang.org/issues/20516)

* Ruby 3.3.2 でまだ脆弱性がある rexml 3.2.6 を参照しているという報告
* rexml の脆弱性に関しては以下で報告されているやつですね
    * [CVE-2024-35176: DoS in REXML](https://www.ruby-lang.org/en/news/2024/05/16/dos-rexml-cve-2024-35176/)
* 各最新のバージョンで参照している rexml は以下の通り

```
$ RBENV_VERSION=3.4-dev gem list rexml

*** LOCAL GEMS ***

rexml (3.2.8, 3.2.6)
$ RBENV_VERSION=3.3.2 gem list rexml

*** LOCAL GEMS ***

rexml (3.2.6)
$ RBENV_VERSION=3.2.4 gem list rexml

*** LOCAL GEMS ***

rexml (3.2.8, 3.2.6, 3.2.5)
$ RBENV_VERSION=3.1.6 gem list rexml

*** LOCAL GEMS ***

rexml (3.2.5)
$ RBENV_VERSION=3.0.7 gem list rexml

*** LOCAL GEMS ***

rexml (3.2.5)
```

* これ自体はまだ対応中みたいですね



## [[Bug #19631] module_eval does not propulate absolute_path for Kernel.caller_locations](https://bugs.ruby-lang.org/issues/19631)

* 次のように `module_eval` 内で `.caller_locations` を参照したとき `absolute_path` が値を返さないバグ報告

```ruby
class Script < Module
  script = %q{
    def self.locations
      Kernel.caller_locations.each { |loc|
        puts "LOCATION: #{loc}"
        puts "ABSPATH:  #{loc.absolute_path}"  # ここの値が空を返すケースがある
        puts "PATH:     #{loc.path}"
      }
    end
    self.locations
  }

  module_eval(script, "/this/is/my/path", 0)
end
```

```
output:
LOCATION: /this/is/my/path:8:in `<class:Script>'
ABSPATH:  
PATH:     /this/is/my/path
LOCATION: /tmp/vY5pBJZ/18:13:in `module_eval'
ABSPATH:  /tmp/vY5pBJZ/18
PATH:     /tmp/vY5pBJZ/18
LOCATION: /tmp/vY5pBJZ/18:13:in `<class:Script>'
ABSPATH:  /tmp/vY5pBJZ/18
PATH:     /tmp/vY5pBJZ/18
LOCATION: /tmp/vY5pBJZ/18:1:in `<main>'
ABSPATH:  /tmp/vY5pBJZ/18
PATH:     /tmp/vY5pBJZ/18
```

* このチケットの起票は 2023/05/06 で約1年前のバグ報告になりますね
* このバグは手元で試した限りだと `3.0.4` 以降のバージョンで再現しました




## [[Bug #20510] File.open mode argument inconsistency](https://bugs.ruby-lang.org/issues/20510)

* `File.new` に以下のような引数を渡すと両方とも同じ動きになることを期待するが後者だとエラーになるバグ報告

```ruby
# OK: 意図する値が返ってくる
p File.new(1, mode: File::WRONLY, path: "foo")
# => #<File:foo>

# NG: エラーになる
p File.new(1, File::WRONLY, path: "foo")
```

* これは `File.new` ってよりかは `IO.new` 側の問題ぽいですね？
    * [IO.for_fd (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/IO/s/for_fd.html)
* `IO.new` 経由だと `path:` や `mode:` みたいなのがキーワード引数で渡すことができるんですねー
* このバグはすでに開発版の Ruby 3.4 では修正済みです
    * https://bugs.ruby-lang.org/issues/20510#note-2





## [[Feature #20508] Explicit access to *, **, &, and ...](https://bugs.ruby-lang.org/issues/20508)

* Ruby で特定の引数の値を取得する機能を追加する提案
* 例えば無名のブロック引数の場合は値を取得できないことがある

```ruby
def splats(one, *, two: nil, **, &)
  # 以下のように無名の位置引数とキーワード引数は出力できる
  p(*)    # => 1
  p(**)   # => {:three=>3}

  # しかしブロック引数は出力できない
  # これはブロック引数のオブジェクトではなくてブロック引数が p に渡されているため
  p(&)

  p binding.local_variables
  # => [:one, :two, :_]
end

splats(:arg, 1, two: true, three: 3) do
  42
end
```

* まあ〜無名引数なんで通常はアクセスするのはむずかしいですねー
* チケットには以下のように `binding` 経由でアクセスする提案がされています

```ruby
def splats(one, *, true: nil, **, &)
  binding.arguments         # 位置引数を返す
  binding.keyword_arguments # キーワード引数を返す
  binding.block_argument    # ブロック引数を返す
end
```

* メタプロとかやっているときは普通に便利そう
* ちなみに以下のようなヘルパ用の `proc` を書けば意図する情報を取得することができるとコメントにかいてありますね
    * https://bugs.ruby-lang.org/issues/20508#note-1

```ruby
arguments, keyword_arguments, block_argument = ->(*a, **kw, &b){[a, kw, b]}.(*, **, &);
```

* とはいえ利用するときは無名引数だけじゃなくて全部の引数がほしいことが多い気がするから `binding` のメソッドとして生えていたほうが便利そう



--------------------------------------------------------------------------------------------------------------------------------------------------------



## [[Feature #20498] Negated method calls](https://bugs.ruby-lang.org/issues/20498)

* 次のように `#exists?` を否定する場合は呼び出し元の先頭に `!` を追加する必要がある

```ruby
must_create_user = !User.where(somelong: :condition, even_more: "thing").exists?
```

* これの視認性が悪いので改善したいという内容のチケット
* 現状だと上記のことを回避する場合は以下のような選択肢がある
    * 変数に代入する
    * `unless` を使う
    * `.!` をチェーンする
        * `.exists?.!`
    * 否定するメソッド名を定義する
* チケットの起票者は以下のような構文を追加する提案をしている

```ruby
# 判定メソッドの直前に ! を追加することで否定する
must_create_user = User.where(somelong: :condition, even_more: "thing").!exists?
```

* 提案された構文は ruby-next ですでにプロトタイプとして実装されているみたいですね
    * https://ruby-next.github.io/#gist:0e133bf6f27f2437193dc034d58083dc
* ただし、このプロトタイプは以下のようなケースには対応してないみたいです

```ruby
# foo が nil のときには nil を返してほしいが
foo&.!empty?
```

* ちなみに `obj.!empty?` は現状でも有効な Ruby の構文で以下のような解釈がされます

```ruby
# obj.! メソッドが呼び出されて、その引数に empty? メソッドの結果が渡される
obj.!(empty?)
```

* コメントでは `.not` や `.!` を使うといいんじゃないか、と書かれていますが判定メソッドに引数がある場合はやはり視認性が悪いとも返信されています
    * https://bugs.ruby-lang.org/issues/20498#note-7

```ruby
puts A.new.exists?(with_friends: true, skip_administrator: true).!
puts A.new.exists?(with_friends: true, skip_administrator: true).not
```

* その他、コメントででていた代替案

```ruby
foo&.empty?&.!
foo&.non&.empty?
foo&.empty?&.not
foo&.!(&:empty?)
```

* `.not.empty?` や `.!(&:empty?)` は既存の機能で便利メソッド定義するような形ですねー

```ruby
class MethodNegator < BasicObject
  def initialize(obj)
    @obj = obj
  end

  def method_missing(method, ...)
    @obj.public_send(method, ...)
  end

  def respond_to_missing?(include_all = false)
    @obj.respond_to?(include_all)
  end
end

module Kernel
  def non(sym=nil)
    if sym
      proc { |*args,**kwargs,&block| !sym.to_proc.call(*args,**kwargs,&block) }
    else
      MethodNegator.new(self)
    end
  end
end

p "".non.empty?
# => true
p ["", "a", "b"].select(&non(:empty?))
# => ["a", "b"]
```

* 個人的にはこういう機能がほしいことは多いんだけど、構文的にちょっと過剰にならないかは気になる
* 他の言語とかこういうケースはどうカバーしているんですかねー
* ちなみに代替案としては以下のようにかけなくもないかなあ…

```ruby
must_create_user = User.where(somelong: :condition, even_more: "thing").then { !_1.exists? }
```




## [[Bug #20474] Heredoc common leading whitespace calculation question](https://bugs.ruby-lang.org/issues/20474)

* 以下のようなヒアドキュメントのときに空白文字が保持されないというバグ報告

```ruby
# 1行目と3行目に空白文字がある
# このときにその空白文字が意図せずに削除されてしまっている
pp eval("<<~H\n     \naaa\n     \nH\n")
# => "\n" + "aaa\n" + "\n"
```

* これ自体は開発版の Ruby 3.4 で修正済み

```ruby
pp eval("<<~H\n     \naaa\n     \nH\n")
# Ruby 3.3 => "\n" + "aaa\n" + "\n"
# Ruby 3.4 => "     \n" + "aaa\n" + "     \n"
```

* ただ、修正前のほうが機能としては便利、みたいな意見もあるみたいですねー
    * https://bugs.ruby-lang.org/issues/20474#note-4




## [[Bug #20421] String#index and String#byteindex don't clear `$~` when offset > size (or bytesize)](https://bugs.ruby-lang.org/issues/20421)

* `$~` の値が正しくクリアされないというバグ報告
* 次のように offset の値が対象の文字列のサイズよりも大きいとクリアされない

```ruby
"a".index(/a/)
p $~ # => #<MatchData "a">

string = "blablabla"
# これはマッチしないので nil を返す
p string.index(/bla/, string.length + 1) # => nil

# しかし $~ の値はそのままになっている
p $~ # => #<MatchData "a">
```

* この不具合はパッチバージョンにバックポート済み

```ruby
"a".index(/a/)
p $~ # => #<MatchData "a">

string = "blablabla"
string.index(/bla/, string.length + 1)
p $~
# Ruby 3.2.3, 3.3.0 => #<MatchData "a">
# Ruby 3.2.4, 3.3.1 => nil
```

* こんなバグがあったんですねー



## [[Bug #20482] nil variables in a guard clause of a standalone => or in expression](https://bugs.ruby-lang.org/issues/20482)

* 次のようなパターンマッチのコードが意図しないエラーになるというバグ報告

```ruby
[1, 2] in a, b if b == 2*a
```

```
x.rb:1:in `*': nil can't be coerced into Integer (TypeError)

[1, 2] in a, b if b == 2*a
                         ^
        from x.rb:1:in `<main>'
```

* 意図としては以下のような `case ~ in` と同等の挙動を期待しています

```ruby
case [1, 2]
in a, b if b == 2*a # キャプチャした変数を参照しつつ条件を指定できる
  true
else
  false
end
# => true
```

* これはいわゆるパターンマッチの if ではなくて後置 if として解釈されるので左辺が評価される前に if 文の条件式が評価されるのでエラーになってしまう感じです

```ruby
# こう解釈される
([1, 2] in a, b) if b == 2*a
```



## [[Bug #20472] Ractor support for ** into hash literal](https://bugs.ruby-lang.org/issues/20472)

* `shareable_constant_value:` の pragma comment があるときに `**nil` で segv するバグ報告
    * これは開発版の Ruby 3.4-dev で再現する

```ruby
# shareable_constant_value: experimental_copy
a = { "foo" => "bar" }
# ここで segv する
A = { **a }
```

* `experimental_copy` 以外も `experimental_everything` や `literal` でも再現しました
* ちなみに `shareable_constant_value` に設定できる値は以下のような感じ
    * `experimental_everything` : マジックコメント移行の定数定義を共有可能オブジェクトにする
    * `experimental_copy` : 値をコピーを共有可能オブジェクトにして定数を定義する
    * `none` : `shareable_constant_value` を無効にする
    * `literal` : 定数定義がリテラルだった場合のみ共有可能オブジェクトにする




## [[Bug #19530] `Array#sum` and `Enumerable#sum` sometimes show different behaviours](https://bugs.ruby-lang.org/issues/19530)

* `Array#sum` と `Enumerable#sum` で挙動に差異があるというバグ報告
* Ruby 3.2 時点では以下のような挙動になり `#sum` の戻り値が異なります

```ruby
class Money
  def initialize(amount)
    @amount = amount.to_f
  end

  def +(other)
    self.class.new(@amount + other.to_f)
  end

  def to_f
    @amount
  end
end

p [7.0].each.sum(Money.new(0))   #=> #<Money:0x00000001005b35f0 @amount=7.0>
p [7.0]     .sum(Money.new(0))   #=> 7.0 💥
```

* これは `Array#sum` で最適化する処理が意図してない挙動になっているのが原因みたいですね
    * https://bugs.ruby-lang.org/issues/19530#note-2
* このバグ自体は Ruby 3.3 で修正されています

```ruby
p [7.0].sum(Money.new(0))
# Ruby 3.3 => 7.0
# Ruby 3.3 => #<Money:0x000079df826c2768 @amount=7.0>
```

* またこれは長期的に存在していたバグなので stable 版にはバックポートしないとのこと
    * https://bugs.ruby-lang.org/issues/19530#note-6
    * なので 3.2.x などには反映されない予定
* ちなみにこの対応によって厳密に `Array#sum` の引数の型を見るようになったので以下のような違いもあります

```ruby
class X
  def +(other)
    to_i + other
  end

  # 暗黙的に Integer に変換されるようにメソッド定義しておく
  def to_i
    5
  end
end

# こっちは元々 Ruby 3.2 系でも動いていた
p [3].each.sum(X.new)
# => 8

# この挙動が変わった
p [3].sum(X.new)
# Ruby 3.2 => error: X can't be coerced into Integer (TypeError)
# Ruby 3.3 => 8
```

* 修正後は `#sum` の引数が Integer 型に変換できればエラーにならなくなりました




## [[Bug #20487] 1..nil is giving range from 1 to inifinity in ruby greater than 2.6](https://bugs.ruby-lang.org/issues/20487)

* `(1..nil)` という Range を定義したときに `1~無限` の範囲として扱われるというバグ報告
* 起票者の意図としては `nil.to_i # => 0` になるので `(1..0)` として扱われるのが期待する挙動とのこと
* これは確かにそう認知する人がいるのか〜〜〜と思いつつ Range で `nil` を渡した場合は無現値として扱われる仕様なので期待する挙動になりますねー

```ruby
# 終端が nil のときとない場合は等価
pp (1..nil) == (1..)

# 両方とも終端は nil を返す
pp (1..nil).end   # => nil
pp (1..).end      # => nil
```




## [[Bug #20468] Segfault on safe navigation in for target](https://bugs.ruby-lang.org/issues/20468)

* 次のように `for` 文でぼっち演算子を使うと segv するというバグ報告

```ruby
for foo&.bar in []; end
```

* こういうコードかけるんですね知らんかった
* 上記のようなコードだとループ毎に内部で `foo.bar=` が呼ばれるんですね

```ruby
class Foo
  def bar=(value)
    pp value
  end
end

foo = Foo.new
nil&.bar = 1
# 内部で foo.bar = が呼ばれる
for foo.bar in [1, 2, 3]; end
__END__
output:
1
2
3
```

* `foo&.bar` の場合にどういう挙動になるのか、って議論がされているんですが以下のような挙動が期待されるんですかねー
    * https://bugs.ruby-lang.org/issues/20468#note-7

```ruby
for temp in [1, 2, 3]
  foo&.bar = temp
end
```

* ちなみに単に `nil` と書いた場合は SyntaxError になりますね

```ruby
# error: Can't assign to nil (SyntaxError)
for nil in [1, 2, 3]; end
```





## [[Feature #20484] A new pragma for eager resolution of classes referenced in rescue clauses.](https://bugs.ruby-lang.org/issues/20484)

* 次のように `rescue` でクラスを参照しているときに『実際に例外が排出されるまで』クラスの有無はチェックされない
* なので以下のようなコードを実行したときに `Hoge` が定義されていなくてもエラーにはならない

```ruby
begin

rescue Hoge => e
end
```

* 以下のように例外が発生して初めて『クラスが定義されているかどうか』がチェックされる

```ruby
begin
  raise "hoge"

# error: uninitialized constant Hoge (NameError)
rescue Hoge => e
end
```

* これを実行前に読み込むようにする提案
    * 起票者は pragma comment で制御できるようにする提案をしている
* これは知らなかった
* 起票者は以下のような間違ったコードを書いてたけど気づくのに遅れた、と問題定義していますね

```ruby
begin

# 本来は SomeModule::SomeClass であるのが正しいが SomeClass になってしまっていた
# この問題が実際に例外が発生するまで問題に気づかなかった
rescue SomeClass => e
end
```

* これは確かに気づかないかも
* とはいえこれは `rescue` だけの問題ではなくて他の構文でも同じですね
* 例えばコメントでは `if` 文の例が提示されています
    * https://bugs.ruby-lang.org/issues/20484#note-3

```ruby
if true
else
  # これは else 節に来るまで実行されないのでエラーにならない
  Hoge
end
```

* うーん確かにこれは実行されないすねー
* こういうのは静的解析ツールで対応するのがいい、とコメントされていますねえ
    * https://bugs.ruby-lang.org/issues/20484#note-4
* ただ Ruby は動的にクラス定義できたりもするので静的解析にも限界がありそう
    * あと外部ファイルで定義されている場合とか


## [[Bug #20478] Circular parameter syntax error rules](https://bugs.ruby-lang.org/issues/20478)

* 以下のような『デフォルト引数のブロック内でその仮引数を参照する』ケースはシンタックスエラーになる

```ruby
def foo(bar = -> { bar }) end       # no lambda parameters
def foo(bar = ->() { bar }) end     # no lambda parameters
def foo(bar = baz { bar }) end      # no block parameters
def foo(bar = baz { _1 + bar }) end # parameters, but no pipes
def foo(bar = baz { it + bar }) end # parameters, but no pipes
```

* しかし、以下のようなケースだとシンタックスエラーにならないというバグ報告

```ruby
def foo(bar = ->(baz) { bar }) end   # lambda parameters
def foo(bar = baz { || bar }) end    # no block parameters but empty pipes
def foo(bar = baz { |qux| bar }) end # block parameters
```

* 2つ目のコードだけ見ると `||` の有無でエラーになったりならなかったりしますねー
* ちなみに挙動自体は循環して参照する形になる

```ruby
def foo(bar = proc { || bar })
  pp bar
  # => #<Proc:0x00007528b612eae0 /tmp/v8mZNpq/14:1>

  # これは自身を返す
  pp bar.call
  # => #<Proc:0x00007528b612eae0 /tmp/v8mZNpq/14:1>
end

foo
```



## [[Feature #20469] dd a JSON addition for Enumerator::ArithmeticSequence](https://bugs.ruby-lang.org/issues/20469)

* `Enumerator::ArithmeticSequence` に対して `#to_json`  などを追加する提案

```ruby
require 'json/add/arithmetic_sequence'

pp ((42...72) % 4).to_json
# => {"json_class"=>"Enumerator::ArithmeticSequence", "b"=>42, "e"=>72, "x"=>true, "s"=>4}
```

* 元々はコア向けの提案だったんですがいまは json gem 側に PR が出し直されてます
    * https://bugs.ruby-lang.org/issues/20469
* これみて初めて知ったんですが json って既存のオブジェクトに対する拡張がいろいろとあるんですねー

```ruby
require "json"

# 通常だとこんな感じ
puts({ pattenr: /^hoge\d+$/ }.to_json)
# => {"pattenr":"(?-mix:^hoge\\d+$)"}

puts (0..42).to_json
# => "0..42"

# 拡張用のライブラリを読み込むとこんな感じ
require 'json/add/regexp'
require 'json/add/range'

puts({ pattenr: /^hoge\d+$/ }.to_json)
# => {"pattenr":{"json_class":"Regexp","o":0,"s":"^hoge\\d+$"}}

puts (0..42).to_json
# => {"json_class":"Range","a":[0,42,false]}
```



## [[Bug #20457] Final `return` is eliminated from the AST](https://bugs.ruby-lang.org/issues/20457)

* 次のように `return` があるコードを `RubyVM::AST` でパースするとその情報が欠落しているというバグ報告

```ruby
def foo
  a = 1
  return a
end
```

* 実際にパースすると以下のような情報が得られ、そこには `return` が含まれていない

```ruby
source = <<~EOS
def foo
  a = 1
  return a
end
EOS

ast = RubyVM::AbstractSyntaxTree.parse(source)
pp ast

# Output is like this:
#
# (SCOPE@1:0-4:3
# tbl: []
# args: nil
# body:
#   (DEFN@1:0-4:3
#    mid: :foo
#    body:
#      (SCOPE@1:0-4:3
#       tbl: [:a]
#       args: (ARGS@1:7-1:7 pre_num: 0 pre_init: nil opt: nil first_post: nil post_num: 0 post_init: nil rest: nil kw: nil kwrest: nil block: nil)
#       body: (BLOCK@2:2-3:10 (LASGN@2:2-2:7 :a (INTEGER@2:6-2:7 1)) (LVAR@3:9-3:10 :a)))))
```

* こういうコードだと `return` って欠落するんだ知らなかった
* モチベーションとしては AST の情報を元にして LSP ツールを作る場合に不都合があるとのこと
* `RubyVM::AST` の結果は最適化されて返ってくるので `return` がなくてもまあ〜〜って気はするし、最適化しない場合は `ripper` の方で解析するイメージはありますね



----------------------------------------------------------------------------------------------------------------------------------



## [[Bug #20450] Ruby 3.3.1 broken with bootsnap](https://bugs.ruby-lang.org/issues/20450)

* Ruby 3.3.1 で bootsnap + zeitwerk を使用するとエラーになるというバグ報告
* `DISABLE_BOOTSNAP=1` すれば動きはするが警告が出るらしい
* PR はでているがまだマージはされていない
    * https://github.com/ruby/ruby/pull/10619
* 暫くは座し待ちですかねえ…
    * やっと Ruby 3.3.1 がでたと思ったら…
* ちなみに以下のようにして修正パッチを取り込む例が書かれています

```shell
ruby-install --patch https://gist.githubusercontent.com/havenwood/57ef01e562bc5ac2939477cc842cc9ad/raw/57ef01e562bc5ac2939477cc842cc9ad/raw/0509f4df6d7e8e5e4a16eae2ef43f903b2b265d6/delete_archdir_prefix.patch ruby-3.3.1
```

```shell
rvm install 3.3.1 --patch https://gist.githubusercontent.com/havenwood/57ef01e562bc5ac2939477cc842cc9ad/raw/57ef01e562bc5ac2939477cc842cc9ad/raw/0509f4df6d7e8e5e4a16eae2ef43f903b2b265d6/delete_archdir_prefix.patch
```

```shell
rbenv install --patch 3.3.1 < <(curl -s https://gist.githubusercontent.com/havenwood/57ef01e562bc5ac2939477cc842cc9ad/raw/0509f4df6d7e8e5e4a16eae2ef43f903b2b265d6/delete_archdir_prefix.patch)
```

```shell
RUBY_APPLY_PATCHES=$(curl -s https://gist.githubusercontent.com/havenwood/57ef01e562bc5ac2939477cc842cc9ad/raw/0509f4df6d7e8e5e4a16eae2ef43f903b2b265d6/delete_archdir_prefix.patch) asdf install ruby 3.3.1
```



## [[Bug #20440] `super` from child class duplicating a keyword argument as a positional Hash](https://bugs.ruby-lang.org/issues/20440)

* 次のように `super` に引数をフォワードする場合にキーワード引数ではなくて位置引数として渡っている、というバグ報告
    * Ruby 2.7 では期待する挙動になっていたが Ruby 3.0 から挙動が変わった

```ruby
class Base
  def foo(*args, x: 1)
    "Base: calling foo with args: #{args}, x: #{x}"
  end
end

class Child < Base
  def foo(*)
    # このときに foo に渡ってきた引数がそのまま親メソッドにフォワードされることを期待するがそのときにキーワード引数ではなくて位置引数として渡ってしまっている
    super
  end
end

pp Child.new.foo(0, x: 2)
# Ruby 2.7 => "Base: calling foo with args: [0], x: 2"
# Ruby 3.0 => "Base: calling foo with args: [0, {:x=>2}], x: 1"
```

* これは `foo(*)` のシグネチャが『位置引数の可変長引数』になっているのが原因で `*` だと『位置引数』として引数を受け取る『位置引数を』 `super` でフォワードすることにある
* なので次のように `foo(*, **)` とすることで『キーワード引数』を受け取りそれをフォワードすることができる

```ruby
class Base
  def foo(*args, x: 1)
    "Base: calling foo with args: #{args}, x: #{x}"
  end
end

class Child < Base
  # * だけだと位置引数で受け取るが ** を付ける事でキーワード引数として値を受け取る事ができる
  def foo(*, **)
    super
  end
end

pp Child.new.foo(0, x: 2)
# => "Base: calling foo with args: [0], x: 2"
```

* 他には `(...)` でも回避する事ができますね

```ruby
class Base
  def foo(*args, x: 1)
    "Base: calling foo with args: #{args}, x: #{x}"
  end
end

class Child < Base
  # * だけだと位置引数で受け取るが ** を付ける事でキーワード引数として値を受け取る事ができる
  def foo(...)
    super
  end
end

pp Child.new.foo(0, x: 2)
# => "Base: calling foo with args: [0], x: 2"
```

* ちなみに Ruby 2.7 と同じ挙動にしたい場合は `ruby2_keywords` が利用できます

```ruby
class Base
  def foo(*args, x: 1)
    "Base: calling foo with args: #{args}, x: #{x}"
  end
end

class Child < Base
  ruby2_keywords def foo(*)
    # このときに foo に渡ってきた引数がそのまま親メソッドにフォワードされることを期待するがそのときにキーワード引数ではなくて位置引数として渡ってしまっている
    super
  end
end

pp Child.new.foo(0, x: 2)
# => "Base: calling foo with args: [0], x: 2"
```




## [[Bug #20433] Hash.inspect for some hash returns syntax invalid representation](https://bugs.ruby-lang.org/issues/20433)

* 次のような `Hash` で `Hash#inspect` の戻り値が Ruby のシンタックスとして無効な値を返すバグ報告

```ruby
{ :a! => 1 } # {:a!=>1}
{ :a? => 1 } # {:a?=>1}
{ :* => 1 }  # {:*=>1}
{ :== => 1 } # {:===>1}
{ :< => 1 }  # {:<=>1}
```

* `{:===>1}` や `{:<=>1}` がシンタックスエラーになるのはわかるんですが `{:a!=>1}` や `{:a?=>1}` もシンタックスエラーになるんですねー
* 以前どこかで『 `#inspect` の結果は必ずしも Ruby の構文として有効とは限らない』みたいな話を聞いたので今回みたいにシンタックスが正しくない出力をするのはしゃーない気はしますね
    * どこで話がでてきたかは忘れた…
    * `Hash#inspect` の結果を `eval` したいみたいなのってどういうニーズなんですがね
* まあ普通に見づらいので `=>` の前後にスペースを入れてもいい気はする


## [[Bug #2044] Kernel#loop: returning the "result" value of StopIteration doesn't work when raised directly](https://bugs.ruby-lang.org/issues/20444)

* `Enumerator#next` でイテレーションするときに『最後の要素』で `#next` を呼び出すと`StopIteration` の例外が発生する
* またこのときに `StopIteration#result` で『例外を発生させる原因となったメソッドなどの戻り』を受け取る事ができる
    * 下記の例だと `Enumerator.new` のブロックの戻り値を返す
    * [StopIteration#result (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/StopIteration/i/result.html)

```ruby
enum = Enumerator.new { |y|
  y << 1
  y << 2
  :ok
}

begin
  pp enum.next   # => 1
  pp enum.next   # => 2
  # 次の要素がないのでここで例外が発生する
  enum.next
rescue StopIteration => e
  # StopIteration#result は Enumerator.new のブロック引数の戻りを返す
  pp "error: #{e.result}"
  # => "error: ok"
end
```

* この `StopIteration` 例外なんですが、実は `Kernel.#loop` でも参照されとり『 `#loop` 内で `StopIteration` 例外が発生したら loop から抜けて `StopIteration#result` の値を返す』という挙動になっている

```ruby
enum = Enumerator.new { |y|
  y << 1
  y << 2
  :ok
}


result = loop {
  # 最後の要素で #next を呼び出すと StopIteration が発生し loop が終了する
  # loop の戻り値は StopIteration#result の値を返す
  pp enum.next
}
pp result
# => :ok
```

* で、ここまでが前ふりなんですがこのチケットでは次のように『意図的に `StopIteration` を発生させた場合に `loop` で意図する値が返ってこない』というバグ報告になる

```ruby
# この場合 3 を返すことを期待するが nil が返ってくる
result = loop {
  raise StopIteration.new(3)
}
pp result
# => nil
```

* これなんですが `StopIteration.new(3)` の `#result` の戻り値が `nil` になるので期待する挙動になる

```ruby
e = StopIteration.new(3)

# message には含まれるが #result は nil になる
pp e.message   # => "3"
pp e.result    # => nil
```

* また Ruby レイヤーでは `StopIteration#result` を設定する事はできないとのこと
    * https://bugs.ruby-lang.org/issues/20444#note-1
* `loop` ほとんど使ったことがないのでこういう挙動があるのは知らなかった


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## [[Feature #15554] warn/error passing a block to a method which never use a block](https://bugs.ruby-lang.org/issues/15554)

* 以下のようにユーザはブロック引数を渡してそれが呼び出されることを期待しているが実際には呼び出されない事がある

```ruby
def my_open(name)
  open(name)
end

# ユーザはブロック引数が呼ばれていることを期待しているが、実際には動かない
my_open(name){|f| important_work_with f }
```

* このような問題を解決するために『ブロック引数を渡しているが、ブロック引数が使用されない場合』に警告を出すようにする対応案
* この対応をするにあたりどこまで対応するのか、ルールや実装はどうするのかの議論がチケット内で行われています
* で、このチケットの内容が matz から Go サインがでたので既に master ブランチにマージされています
* 現状の開発版の Ruby 3.4 では以下のようなコードを `-w` 付きで実行すると警告が出力されるようになっています

```ruby
def foo
end

# ブロック引数を利用していないメソッドにブロック引数を渡すとエラーになる
# warning: the passed block for 'Object#foo' defined at test.rb:2 may be ignored
foo {}
```

* ただ、一旦機能は入ったんですが細かい挙動などはまだ調整しているみたいです
* このあたりの細かい挙動はもう少し落ち着いてから別途まとめようかと思います



## [[Feature #20428] Ability to reference current class/module in lexical scope](https://bugs.ruby-lang.org/issues/20428)

* 以下のように『モジュールのメソッドが呼ばれたときに『呼び出されたクラス/モジュール』ではなくて『定義したスコープのクラス/モジュール』を取得したい』という要望

```ruby
module Foo
  module Bar
    def blah
      # このときに『現在のスコープのクラス』を取得したい
      # Foo::Bar を取得することを期待する
      puts "executing from #{magic_new_keyword}"
    end
  end
end

class Baz
  include Foo::Bar

  def blah
    super

    puts "executing from #{self.class.name}"
  end
end

Baz.new.blah
# 以下のような結果を期待する
# executing from Foo::Bar
# executing from Baz
```

* 単純に `self.class.name` で取得すると『呼び出されたレシーバのクラス』が返ってくるので `Baz` が返ってくるんですが `Foo::Bar` を取得したい意図ですね
* このケースでは `Module.nesting.first` が利用できるとコメントされています
    * https://bugs.ruby-lang.org/issues/20428#note-1

```ruby
module Foo
  module Bar
    def blah
      puts "executing from #{Module.nesting.first}"
    end
  end
end

class Baz
  include Foo::Bar

  def blah
    super

    puts "executing from #{self.class.name}"
  end
end

Baz.new.blah
# output:
# executing from Foo::Bar
# executing from Baz
```

* `Module.nesting` はこのメソッド呼び出した個所に依存するような『クラス/モジュールのネスト情報』を配列で返します

```ruby
module Foo
  module Bar
    pp Module.nesting   # => [Foo::Bar, Foo]
    class Hoge
      def blah
        pp Module.nesting
        # => [Foo::Bar::Hoge, Foo::Bar, Foo]
      end
    end
  end
end

Foo::Bar::Hoge.new.blah
```

* これで解決できたみたいなのでチケット自体は閉じられてます



## [[Bug #20423] Anonymous block forwarding shouldn't work with ... but it does](https://bugs.ruby-lang.org/issues/20423)

* 匿名ブロック引数が意図せずフォワードできるというバグ報告
* 通常、匿名ブロック引数のフォワードは匿名でブロック引数を受け取った場合のみ利用できある

```ruby
# OK
def hoge(&)
  foo(&)
end

# NG: ブロック引数を匿名で受け取ってないとフォワードできない
def bar
  foo(&)
end
```

* これが `(...)` で受け取った場合には匿名ブロック引数をフォワードで来てしまうというバグ報告

```ruby
def hoge(...)
  # これはシンタックスエラーになることを期待するがいまはエラーにならない
  foo(&)
end
```

* PR はでているのでそのうち修正されそう
    * https://github.com/ruby/ruby/pull/10514



## [[Bug #20411] Kenrel.autoload? behaviour](https://bugs.ruby-lang.org/issues/20411)

* `Kenrel.autoload?` の挙動に関するチケット
* 以下のように `Module.autoload?` では期待する値が返ってくるがモジュール内で `Kernel.autoload?` を呼び出した場合は返ってこない

```ruby
autoload :A, "a.rb"

module B
  # こっちでは Kernel.autoload? が nil を返す
  pp Kernel.autoload?(:A)   # => nil
  pp Module.autoload?(:A)   # => "a.rb"
end

# ここでは両方共 `"a.rb"` を返す
pp Kernel.autoload?(:A)   # => "a.rb"
pp Module.autoload?(:A)   # => "a.rb"
```

* これは `Module.autoload?` と `Kernel.autoload?` で対象のスコープが違っているからになります
* `Kernel.autoload?` の方は『現在のスコープの名前空間で検索する』のでこのような挙動になっています

```ruby
autoload :A, "a.rb"

module B
  pp Kernel.autoload?(:A) # => nil
  pp Module.autoload?(:A) # => "a.rb"
  # これは Kernel.autoload? と同等
  pp autoload?(:A)        # => nil
  # B の名前空間に対して判定する
  pp B.autoload?(:A)      # => nil
  puts

  autoload :X, "x.rb"

  # B 内で定義されている場合はこういう判定になる
  pp Kernel.autoload?(:X) # => "x.rb"
  pp Module.autoload?(:X) # => nil
  pp autoload?(:X)        # => "x.rb"
  pp B.autoload?(:X)      # => "x.rb"
  puts
end

pp Kernel.autoload?(:A) # => "a.rb"
pp Module.autoload?(:A) # => "a.rb"
pp autoload?(:A)        # => "a.rb"
pp B.autoload?(:A)      # => nil
puts

pp Kernel.autoload?(:X) # => nil
pp Module.autoload?(:X) # => nil
pp autoload?(:X)        # => nil
pp B.autoload?(:X)      # => "x.rb"
```

* という事でこの挙動自体は仕様になります


## [[Feature #20350] Return chilled string from Symbol#to_s](https://bugs.ruby-lang.org/issues/20350)

* `Symbol#to_s` の戻り値をチルド文字列にする提案
* 以前 [`Symbol#to_s` の戻り値を frozen string にする提案](https://bugs.ruby-lang.org/issues/16150#note-22)があり、開発版で入ったが互換性の問題により最終的に入らなかった事があった
* Ruby 3.4 ではチルド文字列という概念が新しく導入され、チルド文字列を利用すれば事前にこの非互換の問題を対処できるのではないか、という話
* いまのところ進展はなさそうですね
* 全体的にチルド文字列に対する期待値が上がっている気がするけど実際に蓋を明けたらどうなるんだろうなあ
    * 非互換がまったくないわけではない + どれだけ対処が必要なのか…


-------------------------------------------------------------------------------------


## [[Bug #20392] Delegate super calls with a block](https://bugs.ruby-lang.org/issues/20392)

* 次のように `...` とブロック引数を同時に渡すコードはシンタックスエラーになる

```ruby
# Example 1
def foo ...
  yield
end

def bar ...
  # error: both block arg and actual block given (SyntaxError)
  foo(...) { }
end
```

* しかし次のように `super` を経由してブロック引数を渡すとエラーにならず `super` に渡したブロック引数が呼ばれる

```ruby
# Example 2
class A
  def foo
    yield(3)
  end
end

class B < A
  def foo(...)
    # A#foo にはブロック引数が渡され、それが評価される挙動になる
    # super {} は super(...) {} と同等であるはず…？
    super do |x|
      yield(2 + x)
    end
  end
end

# ここで渡したブロック引数は呼び出されない
p B.new.foo { |x| x }
# => 5
```

* また次のように `super(...) {}` で呼び出した場合はそのブロック引数は渡されない

```ruby
# Example 3
class A
  def foo
    yield(3)
  end
end

class B < A
  def foo(...)
    # ここで渡したブロック引数は A#foo には渡されない
    super(...) do |x|
      raise "should I be called?"
    end
  end
end

# ここで渡したブロック引数が呼び出される
p B.new.foo { |x| x }
# => 3
```

* まとめると以下のような感じ
    * Example 1 : シンタックスエラー
    * Example 2 : `super` を呼び出したときのブロック引数が渡される
    * Example 3 * `super(...)` にフォワードしたブロック引数が渡される
    * ちなみに『引数がない `super` のことを `zsuper` と呼んでいる』らしい
* Example 3 に関しては Ruby 3.2 では Example 1 と同じ挙動だったので Ruby 3.3 で挙動が変わってしまったらしい
* また Example 2 に関しては `super` が特殊なのでこのような挙動になっているらしい
* 具体的には `super(arg)` でもブロック引数が暗黙的に渡されるようになっている

```ruby
class A
  def foo(a)
    yield(a) if block_given?
  end
end

class B < A
  def foo(a, &block)
    # super(a) でも暗黙的にブロック引数を A#foo に渡している
    super(a)
  end
end

p B.new.foo(3) { |x| 2 + x }
# => 5
```

* 明示的にブロック引数を渡さないようにするためには `&nil` を渡す必要がある

```ruby
class A
  def foo(a)
    yield(a) if block_given?
  end
end

class B < A
  def foo(a, &block)
    # &nil を渡すことでブロック引数を渡さないことを明示化する
    super(a, &nil)
  end
end

p B.new.foo(3) { |x| 2 + x }
# => nil
```

* このチケットでは Example 2 の場合に Ruby 3.2 と同様にシンタックスエラーになるように修正されている

```ruby
class A
  def foo
    yield(3)
  end
end

class B < A
  def foo(...)
    super(...) do |x|
      raise "should I be called?"
    end
  end
end

p B.new.foo { |x| x }
# Ruby 3.2 => error: both block arg and actual block given (SyntaxError)
# Ruby 3.3 => 3
# Ruby 3.4 => error: both block arg and actual block given (SyntaxError)
```


## [[Feature #20293] Add `Warning.categories` method that returns the warning category names](https://bugs.ruby-lang.org/issues/20293)

* Ruby のコア機能で定義されている警告のカテゴリを返すメソッドを追加する提案
* ユースケースとしては以下のように警告のカテゴリに依存しているときに利用できる

```ruby
# カテゴリが Ruby のバージョンによって変わる可能性があるので Ruby のバージョンごとにメンテする必要がある
@original_warning = defined?(Warning.[]) ? %i[deprecated experimental].to_h {|i| [i, Warning[i]]} : nil
```

* と、言うことで以下のようなメソッドが Ruby 3.4 で追加される予定です
    * これは既に実装済み

```ruby
pp Warning.categories
# => [:deprecated, :experimental, :performance]
```



## [[Bug #20400] Nested BEGIN{} execution order](https://bugs.ruby-lang.org/issues/20400)

* `BEGIN` は通常、定義された順番に実行される

```ruby
BEGIN { print "1" }
print "4"
BEGIN { print "2" }
print "5"
BEGIN { print "3" }
# => 12345
```

* しかし、以下のように `BEGIN` がネストしたときの仕様がドキュメント化されていないらしい

```ruby
BEGIN {
  print "1"
  BEGIN { print "2" }
}
# => 21
```

```ruby
BEGIN {
  print "1"
  BEGIN { print "2" }
  BEGIN { print "3" }
}
# => 231
```

```ruby
BEGIN {
  print "1"
  BEGIN {
    print "2"
    BEGIN { print "3" }
  }
  BEGIN { print "4" }
}
# => 3241
```

* これが意図する挙動なのかどうかというチケット
* これは以下のようなルールで実行されるらしい
    * a. 同じネストレベルに出現した順序で実行される
    * b. ブロックの外より先に実行される
* と、言うことで現状の挙動自体は一貫しているとコメントされている
    * https://bugs.ruby-lang.org/issues/20400#note-1


## [[Feature #20396] ObjectSpace.dump_all(string_value: false): skip dumping the String contents](https://bugs.ruby-lang.org/issues/20396)

* `ObjectSpace.dump_all(string_value: false)` することで文字列のダンプをスキップする提案
* 主に次の理由があげられてます
    * 個人情報や機密情報
    * 多くの場合、文字列の内容はそれほど役には立たない
* デフォルトで `false` にするかどうか話されていますが影響があったりするんですかねー



## [[Bug #20401] Duplicated when clause warning line number](https://bugs.ruby-lang.org/issues/20401)

* 以下のようなコードを実行すると『5行目が無視される』と警告が出るが実際に無視されるのは『8行目』なので実態と異なるというバグ報告

```ruby
foo = :bar

# warning: duplicated `when' clause with line 5 is ignored
case foo
when :bar
  pp "bar1"
when :baz
when :bar
  pp "bar2"
end
# =<> bar1
```

* これは `-W` を付けたときに出力される警告にはなりますね  
* まあ普通に紛らわしいですねー


## [[Bug #20307] `Hash#update` from compare_by_identity hash can have unfrozen string keys](https://bugs.ruby-lang.org/issues/20307)

* 以下のように `compare_by_identity` な Hash を `Hash#update` で取り込むと意図しない挙動になるというバグ報告
    * どうやってみつけるのこれ…

```ruby
key = "a"
hash1 = {}.compare_by_identity
hash1[key] = 0
hash2 = {}.update(hash1)

pp hash1   # => {"a"=>0}
pp hash2   # => {"a"=>0}

pp hash1.compare_by_identity?   # => true
pp hash2.compare_by_identity?   # => false

key.upcase!

# key は大文字の "A" として扱われているが
pp hash2   # => {"A"=>0}
pp hash2.keys   # => ["A"]

# 添字アクセスなどはできない状態になっている
pp hash2[key]   # => nil
pp ((hash2.fetch(key) rescue $!))
# => #<KeyError: key not found: "A">

# compare_by_identity と同じような挙動になる
hash2["A"] = 1
pp hash2
# => {"A"=>0, "A"=>1}
```

* この問題は開発版の Ruby 3.4 で修正済み
    * https://github.com/ruby/ruby/pull/10099
* ちなみに `Hash#compare_by_identity` はレシーバの Hash のキーの一致判定を『オブジェクトの同一性で判定する』ように変更するメソッド

```ruby
hash = { "a" => "homu" }

# これは `"a" のキーが同じオブジェクトとして判定されるので上書きされる
hash["a"] = "mami"
pp hash   # => {"a"=>"mami"}

hash.compare_by_identity

# compare_by_identity すると object_id で比較されるようになるので上書きされない
hash["a"] = "mado"
pp hash   # => {"a"=>"mami", "a"=>"mado"}
```



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## [[Feature #20211] Consider re-adding 3.2-style support of Anonymous Args/Blocks](https://bugs.ruby-lang.org/issues/20211)

* Ruby 3.3 では次のように匿名引数のフォワードが禁止された
    * 参照: [Ruby 3.3.0 で発生しているブロック内で匿名引数を参照したときのバグについて](https://zenn.dev/mamayukawaii/articles/20240111133839)

```ruby
def m(*)
  [1, 2, 3].each { |*| p(*) }
end
m('test', 'test', 'test')
# Ruby 3.2 => p('test', 'test', 'test') が呼ばれる
# Ruby 3.3 => error: anonymous rest parameter is also used within block (SyntaxError)
```

* これに伴い Rubocop が autofix することによって Ruby 3.1+ のコードを上記の問題になるコードに変換してしまう問題があるらしい
    * [Class: RuboCop::Cop::Naming::BlockForwarding — Documentation for rubocop (1.62.1)](https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Naming/BlockForwarding)
    * [Class: RuboCop::Cop::Style::ArgumentsForwarding — Documentation for rubocop (1.62.1)](https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/ArgumentsForwarding)
    * `[1, 2, 3].each { |*a| p(*a) }` を `[1, 2, 3].each { |*| p(*) }` にしてしまうのかな？
* その上で以下のような挙動にする案も提示されていますね

```ruby
def m(*)
  [1, 2, 3].each { p(*) }
end
m('test', 'test', 'test')
# Ruby 3.2 => p('test', 'test', 'test') が呼ばれる
# Ruby 3.3 => p('test', 'test', 'test') が呼ばれる
# Ruby 3.4 => p('test', 'test', 'test') が呼ばれる

def m(*)
  # このときにブロック引数の * を優先する
  [1, 2, 3].each { |*| p(*) }
end
m('test', 'test', 'test')
# Ruby 3.2 => p('test', 'test', 'test') が呼ばれる
# Ruby 3.3 => error: anonymous rest parameter is also used within block (SyntaxError)
# Ruby 3.4 => p(1) p(2) p(3) が呼ばれる
```

* 個人的にはこっちの方が期待する挙動としては自然な気がしますねー


## [[Feature #20275] Avoid extra backtrace entries for rescue and ensure](https://bugs.ruby-lang.org/issues/20275)

* 以下のようなコードを実行すると

```ruby
def raise_nested_exceptions
  raise "First error"
rescue
  begin
    raise "Second error"
  rescue
    raise "Third error"
  end
end

raise_nested_exceptions
```

* 以下のようなエラーが出力される

```shell
-:7:in 'Object#raise_nested_exceptions': Third error (RuntimeError)
	from -:4:in 'Object#raise_nested_exceptions'
	from -:1:in 'Object#raise_nested_exceptions'
	from -:11:in '<main>'
-:5:in 'Object#raise_nested_exceptions': Second error (RuntimeError)
	from -:1:in 'Object#raise_nested_exceptions'
	from -:11:in '<main>'
-:2:in 'Object#raise_nested_exceptions': First error (RuntimeError)
	from -:11:in '<main>'
```

* このときにバックトレースが繰り返し表示される
    * これは CRuby の実装依存らしい
* この繰り返しをやめて以下の様に表示する提案

```shell
-:7:in 'Object#raise_nested_exceptions': Third error (RuntimeError)
	from -:11:in '<main>'
-:5:in 'Object#raise_nested_exceptions': Second error (RuntimeError)
	from -:11:in '<main>'
-:2:in 'Object#raise_nested_exceptions': First error (RuntimeError)
	from -:11:in '<main>'
```

* TruffleRuby と JRuby は既にこのような動作になっているらしい
    * TruffleRuby 23.1.2:
        ```
        -:7:in `raise_nested_exceptions': Third error (RuntimeError)
            from -:11:in `<main>'
        -:5:in `raise_nested_exceptions': Second error (RuntimeError)
            from -:11:in `<main>'
        -:2:in `raise_nested_exceptions': First error (RuntimeError)
            from -:11:in `<main>'
        ```
    * JRuby 9.4.5.0:
        ```
        RuntimeError: Third error
          raise_nested_exceptions at -:7
                           <main> at -:11
        RuntimeError: Second error
          raise_nested_exceptions at -:5
                           <main> at -:11
        RuntimeError: First error
          raise_nested_exceptions at -:2
                           <main> at -:11
        ```
* これは既に開発版の Ruby 3.4 で対応されています
* また、この変更に伴い `caller` の戻り値なども調整されているみたいですね

```ruby
def raise_nested_exceptions
  raise "First error"
rescue
  begin
    raise "Second error"
  rescue
    # caller の数も減る
    p caller
    # Ruby 3.3 => ["test.rb:12:in `rescue in raise_nested_exceptions'", "test.rb:9:in `raise_nested_exceptions'", "test.rb:22:in `<main>'"]
    # Ruby 3.4 => ["test.rb:12:in 'Object#raise_nested_exceptions'", "test.rb:20:in '<main>'"]
  end
end

raise_nested_exceptions
```


## [[Feature #18057] Introduce Array#mean](https://bugs.ruby-lang.org/issues/18057)

* 平均値を求める `Array#mean` を追加する提案
* 以下のように動作する想定です

```ruby
class Array
  def mean(&)
    sum(&).fdiv(length)
  end
end

array = [1, 2, 3]
p array.mean # 2

array = [1.5, 2.2, 3.1]
p array.mean(&:round) # 2.3333333333333335

array = [-3, -2, -1]
p array.mean { |e| e.abs } # 2
```

* 最初は `#average` って名前だったんですが `#mean` って名前のほうが一般的らしいですね
* 2年前のチケットなんですが特に進展がなく、最近コメントがされていたので気づきました
    * https://bugs.ruby-lang.org/issues/18057#note-14
* コメント内だと以下の gem が利用できるとのこと
    * [mrkn/enumerable-statistics](https://github.com/mrkn/enumerable-statistics)
    * [Refinements | Alchemists](https://www.alchemists.io/projects/refinements/#_mean)



## [[Bug #20342] Top level `public`, `private` and `ruby2_keywords` do not work in wrapped load](https://bugs.ruby-lang.org/issues/20342)

* 以下のようにトップレベルで `public` を使っているファイルを  `#load` の第二引数に `true` を渡した状態で読み込むとエラーになるバグ報告

```ruby
# load.rb
public def func = 42
```

```ruby
# load の第二引数に true を渡した状態でトップレベルに public があるファイルを読み込むとエラーになる
# error: `public': undefined method `func' for class `Object' (NameError)
load "load.rb", true
```

* `true` を渡した場合は無名モジュール内で読み込んだファイルが定義されるからなんですかね？
* このバグの PR は既に出てます
    * https://github.com/ruby/ruby/pull/10271
* ちなみに `load` の第二引数に `true` を渡すと無名モジュール内で `load` されます

```ruby
# load.rb

def func = 42

class X
  def get
    func + func
  end
end
```

```ruby
# 通常の load ではトップレベルに load.rb の内容が定義される
load "load.rb"

# load のトップレベルで定義したメソッドやクラスが参照できる
pp func
# => 42

pp X.new.get
# => 84
```

```ruby
# true を渡した場合は無名モジュール内でメソッドやクラスが定義される
load "load.rb", true

# なのでメソッドやクラスは参照できない
# error: undefined local variable or method `func' for main (NameError)
pp func

# error: uninitialized constant X (NameError)
pp X.new.get
```

* トップレベルを汚染せずに読み込みたい場合に利用できおます



## [[Feature #8421] add Enumerable#find_map and Enumerable#find_all_map](https://bugs.ruby-lang.org/issues/8421)

* `#find` のブロックの戻り値がそのままメソッドの戻り値となるような `#find_map` を追加する提案
* イメージ以下のような感じ

```ruby
# user.lazy.filter_map{ _1.profile }.first と同じような感じ
result = users.find_map { _1.profile }
```

* これ自体は11年前にできたチケットなんですが、暫くユースケースが提示されていなくて特に進展はなかったんですが、最近以下のようなユースケースが投稿されていました

```ruby
# 特定の条件に当てはまったときに任意の値を返したい例
# Option 1
def identifier(emails, pattern: /\Ausername\+(?<identifier>[a-z|0-9]+)@domain\.com\z/i)
  result = nil
  emails.each do |email|
    if matches = pattern.match(email)
      result = matches[:identifier]
      break
    end
  end
  result
end

# Option 2
def identifier(emails, pattern: /\Ausername\+(?<identifier>[a-z|0-9]+)@domain\.com\z/i)
  matches = nil
  matches[:identifier] if emails.find { |email| matches = pattern.match(email) }
end
```

* 上記のようなコードは `#find_map` だと以下のように簡略化できるとコメントされています
    * https://bugs.ruby-lang.org/issues/8421#note-3

```ruby
def find_map(collection, &block)
  result = nil
  collection.each do |item|
    break if result = yield(item)
  end
  result
end

def identifier(emails, pattern: /\Ausername\+(?<identifier>[a-z|0-9]+)@domain\.com\z/i)
  # 条件を書きつつ、任意の値を返すような処理になる
  fnd_map(emails) do |email|
    (matches = pattern.match(email)) && matches[:identifier]
  end
end
```

* さらに上のコードに対して `#find_map` を利用しなくても次のように書くこともできるとコメントもされていますね
    * https://bugs.ruby-lang.org/issues/8421#note-4

```ruby
# proposal:
find_map(emails) do |email|
  (matches = pattern.match(email)) && matches[:identifier]
end

# break を使って任意のタイミングでブロックを抜けて、任意の値を返す
emails.find { |email| match = pattern.match(email) and break match[:identifier] }
# => "thecode"
```

* 他には以下のような書き方も
    * https://bugs.ruby-lang.org/issues/8421#note-5

```ruby
emails.find{ pattern.match(it) }&.then{ it[:identifier] }
```

* いろいろと解決方法がありますねー



## [[Feature #20202] Memoized endless method definitions](https://bugs.ruby-lang.org/issues/20202)

* エンドレスメソッド定義でメモ化できる構文を追加する提案

```ruby

class Foo
  # def bar = (@bar ||= :memoized_value) と同じ処理になる
  def bar ||= :memoized_value
end
```

* エンドレスメソッド定義で `=` を利用しているのでこういう書き方が自然に見えるんですかねー
* エンドレスメソッド定義でメモ化したい事はまあまああるので便利そうには見えるんですがエンドレスメソッド定義の `=` は別に代入式ではないので `@bar ||= obj` と混同するのはよくない気はしますねえ
* この提案は以下の理由で Reject されています
    * ユースケースが見当たらない
    * クラスのメソッドセットは一貫性/理解のしやすさのために安定しているべきである
    * 脆弱なメソッドセットは、オブジェクトの形状とメソッド・キャッシュに悪影響を及ぼす可能性がある
    * https://bugs.ruby-lang.org/issues/20202#note-4


## [[Feature #11446] Possible work around for the requirement to supplying arguments like this: .map(&:method, <arguments>)](https://bugs.ruby-lang.org/issues/11446)

* `.map(&メソッド名, そのメソッドの引数)` のような形で引数を渡せるようにする提案
* このチケット自体は8年前になるんですが、最近コメントがされていて目に付きました
* コメントだと以下のコードが提示されていたのでこういう事がやりたいんですかね？

```ruby
module Enumerable
  def each_call(method, *args,  &) = each { _1.send method, *args, & }
  def map_call!(method, *args,  &) = map! { _1.send method, *args, & }
  # ...
end

# [1,2].map! &:+, 1
p [1,2].map_call! :+, 1

# [].each &:instance_eval do
%w[1 2].each_call :instance_eval do
  @v = 1
end
```

* 今だと Numbered parameters を使ったほうがシンプルに書けますねー

```ruby
p [1, 2].map { _1 + 1 }

%w[1 2].each do
  _1.instance_eval { @v = 1}
end
```


## [[Feature #20349] Pattern Matching - Expose local variable captures](https://bugs.ruby-lang.org/issues/20349)

* パターンマッチでキャプチャした値を後から（外から）参照できるようにする提案
* チケットだと以下のようなコードが提示されている

```ruby
require "rubocop"

def ast_from(string)
  case string
  when String then processed_source_from(string).ast
  when RuboCop::ProcessedSource then string.ast
  when RuboCop::AST::Node then string
  else nil
  end
end

def longform_block?(node)
  node in [:block,                            # s(:block,
           [:send, target, target_method],    #   s(:send, s(:array), :select),
           [[:arg, v]],                       #   s(:args, s(:arg, :v)),
           [:send, [:lvar, ^v], block_method] #   s(:send, s(:lvar, :v), :even?))
  ]
end

longform_block?(ast_from("[1, 2, 3].select { |v| v.even? }"))
# => true

# longform_block? 内でキャプチャしたローカル変数を外から参照する
PatternMatch.last_match.transform_values(&:source)
# => {:node=>"[1, 2, 3].select { |v| v.even? }",
# :result=>"[1, 2, 3].select { |v| v.even? }",
# :target=>"[1, 2, 3]",
# :target_method=>:select,
# :v=>:v,
# :block_method=>:even?}

# 以下のように値を取得するイメージ
def longform_block?(node)
  result = node in [:block,                        # s(:block,
                    [:send, target, target_method],    #   s(:send, s(:array), :select),
                    [[:arg, v]],                       #   s(:args, s(:arg, :v)),
                    [:send, [:lvar, ^v], block_method] #   s(:send, s(:lvar, :v), :even?))
  ]

  pp(binding.local_variables.to_h { [_1, binding.local_variable_get(_1).then { |s| s.source rescue s }] })

  result
end
```

* `Regexp.last_match` と同じような機能がほしい、って感じみたいですね
* これを実現する場合にパターンマッチ毎に内部で値を保持するようにする必要があるのでパフォーマンスに影響がありそうだなーと思ったら同じことがコメントにもかかれていましたね
    * https://bugs.ruby-lang.org/issues/20349#note-1
    * 実際に `Regexp.last_match` がパフォーマンスの問題になっているらしい
* 個人的には `binding` からいい感じにローカル変数の情報を返すようにすればいいんじゃないかなー



------------------------------------------------------------------------------





## [[Bug #20319] Singleton class is being frozen lazily in some cases](https://bugs.ruby-lang.org/issues/20319)

* 通常であれば `#freeze` するとそのオブジェクトの特異クラスも `freeze` される

```ruby
object = Object.new
klass = object.singleton_class
object.freeze
pp klass.frozen?   # => true
```

* しかし、次のように `singleton_class` をネストして参照している場合に意図しないタイミングで `freeze` されるというバグ報告

```ruby
object = Object.new
klass = object.singleton_class.singleton_class
object.freeze

# ここでは false を返す
pp klass.frozen?   # => false

# 特異クラスを参照し直すと
object.singleton_class.singleton_class

# true を返すようになる
pp klass.frozen?   # => true
```

* これ自体はバグなんですが、他の対応として『そのオブジェクトのみを freeze する』みたいなシンプルな仕様にする案もでていますね
    * https://bugs.ruby-lang.org/issues/20319#note-3


## [[Feature #20318] Pattern matching `case ... in` support for triple-dot arguments](https://bugs.ruby-lang.org/issues/20318)

* `case ... in` で `...` を渡せるようにする提案
    * `...` は転送引数
* 現状だと以下のように引数を Hash パターンで書いたり

```ruby
def foo(*args, **kwargs, &block)
  case { args:, kwargs:, block: }
  in args: [name]
    puts name
  in args: [first_name, last_name]
    puts "Hi there #{first_name} #{last_name}"
  in kwargs: {greeting:}
    puts "Hello #{greeting}"
  else
    puts "No match: #{args}"
  end
end

foo "Hi"
foo "Brad", "Gessler"
foo greeting: "Brad"
```

* Array パターンで書いたりする

```ruby
def bar(*args, **kwargs, &block)
  case [args, kwargs, block]
  in [name], {}, nil
    puts name
  in [first_name, last_name], {}, nil
    puts "Hi there #{first_name} #{last_name}"
  in [], {greeting:}, nil
    puts "Hello #{greeting}"
  else
    puts "No match: #{args}, #{kwargs}"
  end
end

bar "Howdy"
bar "Bradley", "Gessler"
bar greeting: "Bradley"
```

* これを以下のように転送引数を直接 `case` に渡せるようにする提案

```ruby
def foo(...)
  case ...
    in args: [name]
      puts name
    in args: [first_name, last_name]
      puts "Hi there #{first_name} #{last_name}"
    in kwargs: {greeting:}
      puts "Hello #{greeting}"
    else
      puts "No match: #{args}"
  end
end

foo "Hi"
foo "Brad", "Gessler"
foo greeting: "Brad"
```

* もしくは `[], {}, block` で受け取るパターン

```ruby
def bar(...)
  case ...
  in [name], {}, nil
    puts name
  in [first_name, last_name], {}, nil
    puts "Hi there #{first_name} #{last_name}"
  in [], {greeting:}, nil
    puts "Hello #{greeting}"
  else
    puts "No match: #{args}, #{kwargs}"
  end
end

bar "Howdy"
bar "Bradley", "Gessler"
bar greeting: "Bradley"
```

* また以下のように `def ~ end` 構文に直接 `in` を書く提案もコメントでされている
    * https://bugs.ruby-lang.org/issues/20318#note-3

```ruby
def foo(...)
in [name]                                     # foo('ko1')
  puts name
in [first_name, last_name]                    # foo('ko1', 'ssd')
  puts "Hi there #{first_name} #{last_name}"
in {greeting:}                                # foo(greeting: 'hello')
  puts "Hello #{greeting}"
else
  puts "No match: #{args}"
end
```

* 上記の書き方は以下のように 1行def で似たような書き方ができるともコメントされていますね
    * これはこれで面白い

```ruby
def foo(*, **) = case [*, **]
in name, {}
  puts name
in first_name, last_name, {}
  puts "Hi there #{first_name} #{last_name}"
in [{greeting:}]            
  puts "Hello #{greeting}"
in *args
  puts "No match: #{args}"
end

foo('ko1') #=> "ko1"
foo('ko1', 'ssd') #=> "Hi there ko1 ssd"
foo(greeting: 'hello') #=> Hello hello
foo('ko1', 'ssd', greeting: 'hello') #=> No match: ["ko1", "ssd", {:greeting=>"hello"}]
```

* 他にも以下のように `when` で分岐できたり

```ruby
def foo
when (name)                                     # foo('ko1')
  puts name
when (first_name, last_name)                    # foo('ko1', 'ssd')
  puts "Hi there #{first_name} #{last_name}"
when (greeting:)                                # foo(greeting: 'hello')
  puts "Hello #{greeting}"
else
  puts "No match: #{args}"
end
```

* ブロック引数でも利用したいなどのコメントもされています

```ruby
HTTP.post("http://example.com/some-resource", "some data") do |...|
in code: (200...300)
  puts "Success!"
in code: (300...400), location:
  puts "Redirect to #{location}"
  # post to location
in code: (500...600)
  puts "Server error"
  do_retry
end
```

* いずれの書き方も面白いとは思いつつ、現状の構文と比べてできないことができるようになるわけではないのでなんかもっといい感じの拡張機能がほしい


## [[Feature #20326] Add an `undefined` for use as a default argument.](https://bugs.ruby-lang.org/issues/20326)

* 『（`nil` も含めて）引数が渡されなかったこと』を判定するために以下のように書くことがある

```ruby
class Array
  # 『未定義用』のオブジェクトを生成しておく
  UNDEFINED = Object.new
  def UNDEFINED.inspect = 'UNDEFINED'
  UNDEFINED.freeze

  def count(item = UNDEFINED)
    # 『未定義のオブジェクトが引数の時のみ』引数がなかったと判定する
    if item == UNDEFINED
      # ...
    end
  end
end
```

* このようなオブジェクトを返す `undefined` を追加する提案

```ruby
class Array
  def count(item = undefined)
    # #undefined? で判定できる
    if item.undefined?
      # ...
    end
  end
end
```

* これの問題点として『`undefined` を引数として渡すことができる』と指摘されていますね
    * `hoge(undefined)` みたいにできてしまう
    * JavaScript と同じ問題が発生する、とも書かれていますね…
* 現状だと以下のように簡略的にかけるともコメントされています
    * https://bugs.ruby-lang.org/issues/20326#note-1

```ruby
class Array
  def count(item = (item_not_set = true))
    if item_not_set
      # 引数が渡されなかった場合
    else
      # 引数が渡された場合
    end
  end
end
```

* これは芸術点が高い
* 他には以下のように『任意の引数が渡されたかどうか』を判定するメソッドを追加するコメントもされていますね

```ruby
def fetch(item, default = nil)
  if arg_given?(:default)
    # ...
  end
end
```

* 稀によくこういうことをしたいケースはなくはないんですがどう書くとスマートなんですかね
    * わたしの場合は可変長引数でカバーしちゃう事が多いかなあ


## [[Bug #20327] Time.new behaves differently when passing a zone as timezone object](https://bugs.ruby-lang.org/issues/20327)

* `Time.new` に秒を Rational、タイムゾーンにタイムゾーンオブジェクトを渡すと不正な `utc_offset` を返すというバグ報告

```ruby
require "tzinfo"

# 以下は正しい値が返ってくる
puts Time.new(2024, 1, 1, 23, 59, 59.9r, "UTC").utc_offset
# => 0

puts Time.new(2024, 1, 1, 23, 59, 59.9r, "UTC").inspect
# => "2024-01-01 23:59:59.9 UTC"

# タイムゾーンオブジェクトを渡すと意図しない値が返ってくる
puts Time.new(2024, 1, 1, 23, 59, 59.9r, TZInfo::Timezone.get("Etc/UTC")).utc_offset
# => (9/10)

puts Time.new(2024, 1, 1, 23, 59, 59.9r, TZInfo::Timezone.get("Etc/UTC")).inspect
# => "2024-01-01 23:59:59.9 +000001"
```

* この問題は開発版の Ruby 3.4 で修正済みです


## [[Bug #20314] Simultaneous Timeout expires may raise an exception after the block](https://bugs.ruby-lang.org/issues/20314)

* 以下のように同時刻にタイムアウトの期限が切れたときにブロックの後に例外が発生する可能性がある、というバグ報告

```ruby
require "timeout"

class A < Exception
end

class B < Exception
end

begin
  Timeout.timeout(0.1, A) do
    Timeout.timeout(0.1, B) do
      nil while true
    end
  end
rescue A, B
  p $! #=> #<A: execution expired>

  # 上記の呼び出しが返ってきた後に例外 B が発生する
  #=> test.rb:16:in `p': execution expired (B)

  p :end # not reach
end
```

* いくつかの解決策も提示されていますが今の所これといった対応はまだされてないようですね


## [[Bug #20324] `(1..).overlap?('foo'..)` returns true](https://bugs.ruby-lang.org/issues/20324)

* `(1..).overlap?('foo'..)` が `true` を返すというバグ報告
* Ruby 3.3.0 時点だと `(a..).overlap?(b..)` または `(..a).overlap?(..b)` のときに `a` や `b` がなんなのか関わらず常に `true` を返す挙動になっているらしい
* 開発版の Ruby 3.4 はこれが比較可能な時のみ `true` を返すように修正済み

```ruby
pp (1..).overlap?('foo'..)
# Ruby 3.3.0 => true
# Ruby 3.4   => false
```



------------------------------------------------------------------------------------------------------------------


## [[Bug #20175] Broken File.dirname(__FILE__) in eval blocks](https://bugs.ruby-lang.org/issues/20175)

* Ruby 3.3 で `eval` 内で `File.dirname(__FILE__)` を呼び出したときの結果が壊れているというバグ報告
* 以下のようなコードを Ruby 3.2 で実行した場合

```ruby
# eval.rb
eval('puts file: __FILE__, dirname: File.dirname(__FILE__)')
```

* 以下のような結果になる

```shell
## Ruby 3.2.2

ruby eval.rb
# {:file=>"(eval)", :dirname=>"."}

ruby ./eval.rb
# {:file=>"(eval)", :dirname=>"."}

cd folder && ruby ../eval.rb
# {:file=>"(eval)", :dirname=>"."}
# 正しいディレクトリを指さないが、有効なパスを返す

ruby /Codes/eval.rb
# {:file=>"(eval)", :dirname=>"."}
# 正しいディレクトリを指さないが、有効なパスを返す
```

* 一方で Ruby 3.3 では以下のような結果になる

```shell
## Ruby 3.3.0

ruby eval.rb
# {:file=>"(eval at eval.rb:1)", :dirname=>"."}

ruby ./eval.rb
# {:file=>"(eval at ./eval.rb:1)", :dirname=>"(eval at ."}
# パスが壊れている

cd folder && ruby ../eval.rb
# {:file=>"(eval at ../eval.rb:1)", :dirname=>"(eval at .."}
# 正しいディレクトリを刺そうとしているがパスが壊れている

ruby /Codes/eval.rb
# {:file=>"(eval at /Codes/eval.rb:1)", :dirname=>"(eval at /Codes"}
# 正しいディレクトリを刺そうとしているがパスが壊れている
```

* `__FILE__` が変更されているのは意図的らしいんですが `File.dirname("(eval)")` が `.` を返すのは偶発的なので依存しないで、とコメントされていますね
    * https://bugs.ruby-lang.org/issues/20175#note-1
* その上で `File.dirname(__FILE__)` は `__dir__` に置き換えることができる、とも書いてあります
    * ただし `eval("__dir__")` は `nil` を返す
* `eval` 内で利用する場合は `eval("__dir__", binding, __FILE__)` みたいにするのがよいんですかね



## [[Feature #20163] Introduce #bit_count method on Integer](https://bugs.ruby-lang.org/issues/20163)

* 数値を2進数に置き換えたときに `1` の数を返す `#bit_count` を追加する提案

```ruby
n = 19
p n.bit_count      #=> 3
p (-n).bit_count   #=> 3

# 以下と対等
p n.to_s(2).count("1")   #=> 4
```

* ビルドインで実装した場合には単純に7倍早くなっているみたいですね
    * https://bugs.ruby-lang.org/issues/20163#note-6

```ruby
(0..10_000_000).each { |x| x.to_s(2).count('1') }
processing time: 3.714706s

(0..10_000_000).each { |x| ruby_pop_count(x) }
processing time: 3.367775s

(0..10_000_000).each { |x| x.pop_count }
processing time: 0.515767s
```

```ruby
def ruby_pop_count(n)
  n = n.abs
  count = 0
  while n > 0
    n &= n - 1
    count += 1
  end
  count
end
```

```c
unsigned int pop_count(long value) {
#ifdef __GNUC__
    // Use GCC built-in
    return __builtin_popcountl(value);
#else
    // Fallback method for compilers without the built-in
    unsigned int count = 0;
    while (value) {
        count += value & 1;
        value >>= 1;
    }
    return count;
#endif
}

// Wrapper function for Ruby
VALUE rb_pop_count(VALUE self) {
    long value = NUM2LONG(self);
    unsigned int count =  pop_count(labs(value));
    return UINT2NUM(count);
}
```


## [[Feature #20300] Hash: set value and get pre-existing value in one call](https://bugs.ruby-lang.org/issues/20300)

* 『Hash を更新しつつ、更新前の値を取得する』場合に以下のように同じ要素に対して2回参照する必要がある

```ruby
h = { k: "old value" }

# 1. :k を参照して更新前の値を取得する
old_value = h[:k]
# 2. もう一度 :k を参照して更新を行う
h[:k] = "new value"

use(old_value)
```

* このときに Symbol 以外でアクセスした場合に `#hash` や `#eql?` を呼び出すコストがかかる
* なのでこれをまとめて操作する `Hash#update_value` を追加する提案
* Ruby だと以下のような感じ
    * 実際には参照を1回にするために C で実装する必要がある

```ruby
class Hash
  def update_value(key, new_value)
    old_value = self[key]
    self[key] = new_value
    old_value
  end
end
```

* 既に PR は出ていていまは名前をどうするのかって議論がされている
    * [Add `Hash#exchange_value` by amomchilov · Pull Request #10092 · ruby/ruby](https://github.com/ruby/ruby/pull/10092)
* またこのメソッドを利用したいユースケースは [[Bug #20301] `Set#add?` does two hash look-ups](https://bugs.ruby-lang.org/issues/20301) を参照



## [[Bug #20301] `Set#add?` does two hash look-ups](https://bugs.ruby-lang.org/issues/20301)

* `Set#add?` は『要素が追加された場合は `self` を返し、そうでない場合は `nil` を返す』というメソッドになる
    * [class Set (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/class/Set.html#I_--3C--3C)

```ruby
set = Set[1, 2]

# 要素がないので self を返す
pp set.add?(3)
# => #<Set: {1, 2, 3}>

# 既に要素があるので nil を返す
pp set.add?(1)
# => nil
```

* この `Set#add?` の実装では `@hash` の要素を2回参照している

```ruby
class Set
  def add?(o)
    # 1. `include?(o)` で `@hash` の要素を参照している
    # 2. `add(o)` で2回目の `@hash` の要素を参照している
    add(o) unless include?(o)
  end
end
```

* これを内部で [[Feature #20300] Hash: set value and get pre-existing value in one call](https://bugs.ruby-lang.org/issues/20300) を利用することで改善したいという内容のチケット

```ruby
class Set
  def add?(o)
    # #update_value を利用することで参照を1回にする
    self unless @hash.update_value(o, true)
  end
end
```

* チケット内にベンチマークが載っているんですが（見方がよくわからない…）早くなっていると提示されていますねー
* ちなみに以下のような実装案もコメントに書いてあるんですがこれだとブロックを呼び出すオーバーヘッドがあるらしく、そこまで改善しないらしい
    * https://bugs.ruby-lang.org/issues/20301#note-6

```ruby
def add?(k)
  added = false
  # 要素が追加された時のみブロックが呼び出される
  @hash.add(k){ added = true }
  self if added
end
```

* あと以下のような対応案もあるがこっちはスレッドセーフではないみたいですね
    * https://bugs.ruby-lang.org/issues/20301#note-8

```ruby
def add?(o)
  n = size
  add(o)
  m = size
  return n == m ? nil : self
end
```


## [[Bug #20294] Parser no longer warns on some duplicated keys](https://bugs.ruby-lang.org/issues/20294)

* 開発版の Ruby で次のコードを実行したときに『キーが重複している』警告がでないというバグ報告

```ruby
{ 100.0 => 1, 1e2 => 1 }
{ 100.0 => 1, 1E2 => 1 }
{ 100.0 => 1, 100.00 => 1 }
{ 100.0r => 1, 100.00r => 1 }
{ 100.0i => 1, 100.00i => 1 }
```

* 本来であれば以下のような警告が出力されるが開発版の Ruby だとなにも出力されない

```ruby
/tmp/v7qf6jo/16:1: warning: key 100.0 is duplicated and overwritten on line 1
/tmp/v7qf6jo/16:2: warning: key 100.0 is duplicated and overwritten on line 2
/tmp/v7qf6jo/16:3: warning: key 100.0 is duplicated and overwritten on line 3
/tmp/v7qf6jo/16:4: warning: key (100/1) is duplicated and overwritten on line 4
/tmp/v7qf6jo/16:5: warning: key (0+100.0i) is duplicated and overwritten on line 5
```


## [[Feature #20196] Proposal: Binary data literal](https://bugs.ruby-lang.org/issues/20196)

* 以下のようなバイナリデータを定義するリテラル（％記法？）を追加する提案

```ruby
%b[
  89504e470d0a1a0a # PNG header
  0000000d         # Length = 13 bytes
  49484452         # IHDR chunk
  00000060         # Width = 96px
  00000060         # Height = 96px
  08 06            # 8bpp RGBA
  00 00 00         # deflate / no filter / non-interlaced
]

# => "\x89PNG\r\n\x1A\n\x00\x00\x00\rIHDR\x00\x00\x00`\x00\x00\x00`\b\x06\x00\x00\x00"
```

* 仕様は以下のような感じ
    * 16進文字列(上位ニブルが先)
    * 他の％記法と同じルール
    * `%b[]` は `String` を返し `%B[]` は `IO::Buffer` を返す
    * 空白文字は無視される
    * コメントを書くことができる
    * エンコーディングは `Encoding::BINARY` になる
    * 結果の文字列は `frozen` になる
    * `a-f` は `A-F` ともかける
* 普段 Ruby のコードを書いている時にバイナリデータを直接コードを書くことはないんですが、あると使う場面があったりするんですかねー
* 他には以下のような『空白文字を取り除きコメントをサポートする%記法を新しく追加する』みたいな話もあります
    * https://bugs.ruby-lang.org/issues/20196#note-3

```ruby
%c[
  The quick brown # comment
  fox jumped over # another comment
  the lazy dog.   # a third comment
] # => "The quick brown fox jumped over the lazy dog."

# 今回のケースはこういう風にかける
[%c[
    000102 # foo
    030405 # bar
].delete(' ')].pack("H*").freeze
```

* これだと汎用性があるのでより利用できそうな場面はありそうですね
* また、以下のように実装することもできるとコメントに書いてありますね
    * https://bugs.ruby-lang.org/issues/20196#note-6

```ruby
module Kernel
  def Binary(string, exception: true)
    hex = string.b
    hex.gsub!(/#[^#]*$\R*/, '')
    hex.gsub!(/"[^"]*"/) do |quotes|
      quotes[1..-2].unpack1('H*')
    end
    hex.delete!("\s\t")

    if hex.match?(/\H/)
      return unless exception

      invalid_chars = hex.scan(/\H/).to_set.join
      raise ArgumentError,
            "invalid non-hex chars for Binary(): #{invalid_chars.inspect}"
    end 
        
    [hex].pack('H*').freeze
  end   
end     
        
string = <<-BINARY
  89 "PNG" 0d0a1a0a # PNG header
  0000000d          # Length = 13 bytes
  "IHDR"            # IHDR chunk
  00000060          # Width = 96px
  00000060          # Height = 96px
  08 06             # 8bpp RGBA
  00 00 00          # deflate / no filter / non-interlaced}
BINARY  
        
binary = Binary(string)
pp string: binary, encoding: binary.encoding, frozen: binary.frozen?
# => {:string=>"\x89PNG\r\n" + "\x1A\n" + "\x00\x00\x00\rIHDR\x00\x00\x00`\x00\x00\x00`\b\x06\x00\x00\x00",
#    :encoding=>#<Encoding:ASCII-8BIT>,
#    :frozen=>true}
```

* これはこれで面白い


## [[Misc #20191] Deprecate magic encoding comment](https://bugs.ruby-lang.org/issues/20191)

* ファイルのエンコーディングを utf-8 で統一し、エンコーディングを指定するマジックコメントを非推奨にする提案
* モチベーションとしてはパーサー/コンパイラのパフォーマンスの改善と簡素化が上げられている
* この変更はかなり強い非互換になってしまうので現時点では Reject されている
    * https://bugs.ruby-lang.org/issues/20191#note-3


## [[Bug #20299] Tracepoint staying enable after a disable](https://bugs.ruby-lang.org/issues/20299)

* TracePoint を無効にした後も有効になったままになっているというバグ報告

```ruby
def check_speed(msg)
  t1 = Time.now.to_f
  a = 0
  1000000.times { |i|
    a += 10
  }
  t2 = Time.now.to_f
  puts "#{t2-t1} - #{msg}"
end

check_speed("before") # fast

trace = TracePoint.new(:line) {}
trace.enable

check_speed("after enable") # slow
trace.enable {
  check_speed("in block enable") # slow
}
check_speed("after block enable") # slow

trace.disable
check_speed("after disable") # slow !!!!

trace.disable
check_speed("after disable again") # fast !!!!

# And yet, using enable multiple time doesn't have a "counter" or similar
trace.enable
trace.enable
trace.enable
check_speed("after triple enable") # slow
trace.disable
check_speed("after single disable") # fast
```

```
$ ruby -v
ruby 3.3.0 (2023-12-25 revision 5124f9ac75) [x86_64-linux]
$ ruby local.rb
0.03473854064941406 - before
0.18935227394104004 - after enable
0.17757630348205566 - in block enable
0.18320131301879883 - after block enable
0.1818866729736328 - after disable
0.03412747383117676 - after disable again
0.18405628204345703 - after triple enable
0.033496856689453125 - after single disable
```

* Ruby 3.2 だとまた結果が異なる

```
$ rvm use 3.2.3
Using /home/max/.rvm/gems/ruby-3.2.3
$ ruby local.rb
0.03246927261352539 - before
0.07910513877868652 - after enable
0.10309600830078125 - in block enable
0.12397646903991699 - after block enable
0.07114601135253906 - after disable
0.028218746185302734 - after disable again
0.12534689903259277 - after triple enable
0.02810525894165039 - after single disable
```

* 遅い = 有効のままになっている、ってことなんですかねー
* 割と影響が大きそう


## [[Feature #20298] Introduce `Time()` type-cast / constructor.](https://bugs.ruby-lang.org/issues/20298)

* `Time` へのキャストを行う `Time()` メソッドを追加する提案
    * `Integer()` や `Float()` などと同じようなメソッド
* 実装イメージは以下のような感じ

```ruby
def Time(value)
  case value
  when Time
    value
  when Integer
    Time.at(value)
  when String # `Time#to_s` の結果を受け取ることを想定
    Time.new(value)
  else
    value.to_time
  end
end
```

* 背景としては JSOIN をシリアライズ化したときに利用したいらしい

```ruby
data = fetch_job_data
job = @coder.load(data)
scheduled_at = Time(job[:scheduled_at]) # ここで Time に復元するときに利用したい
```

* これに対して `ClassName()` を追加するのは反対するコメントもされてます
    * https://bugs.ruby-lang.org/issues/20298#note-2
    * `ClassName.coerce()` の方がより Ruby として自然とも書いてあります


## [[Feature #20164] Add Exception#deconstruct_keys](https://bugs.ruby-lang.org/issues/20164)

* `Exception#deconstruct_keys` を追加して `Exception` に対してパターンマッチに対応させる提案

```ruby
begin
  #code
rescue => err
  case err
  in StandardError(message: /Permission denied/)
    abort "please select a different file"
  in NameError(name: :foo)
    retry if require "foo_helper"
  else
    raise
  end
end
```

* また各 `Exception` のサブクラスごとにどのキーが対応しているのかも含めて実装する必要がある、とコメントされている
    * https://bugs.ruby-lang.org/issues/20164#note-1
* 具体的には以下のような感じ
    * https://bugs.ruby-lang.org/issues/20164#note-2

```
Exception                                [:backtrace, :backtrace_locations, :cause, :message]
StopIteration                            [:result]
FrozenError                              [:receiver]
SignalException                          [:signo, :signm]
KeyError                                 [:receiver, :key]
LoadError                                [:path]
LocalJumpError                           [:exit_value, :reason]
NameError                                [:name, :receiver, :local_variables]
NoMatchingPatternKeyError                [:key, :matchee]
NoMethodError                            [:args, :private_call?]
SyntaxError                              [:path]
SystemCallError                          [:errno]
SystemExit                               [:status, :success?]
UncaughtThrowError                       [:tag, :value]
Encoding::InvalidByteSequenceError       [:readagain_bytes, :source_encoding, :source_encoding_name, :incomplete_input?, :destination_encoding, :destination_encoding_name, :error_bytes]
Encoding::UndefinedConversionError       [:error_char, :source_encoding, :source_encoding_name, :destination_encoding, :destination_encoding_name]
OptionParser::ParseError                 [:args, :reason, :additional]
Ractor::RemoteError                      [:ractor]
Timeout::Error                           [:thread]
RDoc::RI::Driver::NotFoundError          [:name]
RDoc::Store::MissingFileError            [:name, :file, :store]
Reline::Config::InvalidInputrc           [:file, :lineno]
Gem::LoadError                           [:name, :requirement]
Gem::ConflictError                       [:target, :conflicts]
Gem::DependencyResolutionError           [:conflict, :conflicting_dependencies]
Gem::FilePermissionError                 [:directory]
Gem::FormatException                     [:file_path]
Gem::GemNotInHomeException               [:spec]
Gem::ImpossibleDependenciesError         [:request, :build_message, :dependency, :conflicts]
Gem::MissingSpecVersionError             [:specs]
Gem::RuntimeRequirementNotMetError       [:suggestion]
Gem::SpecificGemNotFoundException        [:name, :errors, :version]
Gem::SystemExitException                 [:exit_code]
Gem::UninstallError                      [:spec]
Gem::UnknownCommandError                 [:unknown_command]
Gem::UnsatisfiableDependencyError        [:name, :dependency, :errors, :version]
Gem::RequestSet::Lockfile::ParseError    [:column, :path, :line]
Gem::Resolver::Molinillo::CircularDependencyError [:dependencies]
Gem::Resolver::Molinillo::NoSuchDependencyError [:dependency, :required_by]
Gem::Resolver::Molinillo::VersionConflict [:specification_provider, :conflicts]
```

* これはまあ普通に便利そうな気がする


## [[Bug #20186] Ripper does not generate AST for some keywords in Ruby 3.3](https://bugs.ruby-lang.org/issues/20186)

* Ripper で特定のキーワードをパースしたときに Ruby 3.3 から AST の情報が取得できなくなっているというバグ報告
* Ruby 3.2 だと以下のように情報を取得できるが

```shell
$ ruby -v
ruby 3.2.2 (2023-03-30 revision e51014f9c0) [x86_64-linux]
$ ruby -rripper -e "p Ripper.sexp('break')"
[:program, [[:break, []]]]
$ ruby -rripper -e "p Ripper.sexp('next')"
[:program, [[:next, []]]]
$ ruby -rripper -e "p Ripper.sexp('redo')"
[:program, [[:redo]]]
$ ruby -rripper -e "p Ripper.sexp('retry')"
[:program, [[:retry]]]
$ ruby -rripper -e "p Ripper.sexp('yield')"
[:program, [[:yield0]]]
```

* Ruby 3.3 だと情報が取得できなくなっている

```shell
$ ruby -v
ruby 3.3.0 (2023-12-25 revision 5124f9ac75) [x86_64-linux]
$ ruby -rripper -e "p Ripper.sexp('break')"
nil
$ ruby -rripper -e "p Ripper.sexp('next')"
nil
$ ruby -rripper -e "p Ripper.sexp('redo')"
nil
$ ruby -rripper -e "p Ripper.sexp('retry')"
nil
$ ruby -rripper -e "p Ripper.sexp('yield')"
nil
```

* この影響で `rufo` に影響がでているらしい
    * https://github.com/ruby-formatter/rufo/issues/319
* どれもトップレベルでは利用できないキーワードなんですが、内部ではどういう風に扱われるんですかねー


## [[Bug #19973] Duplicate keyword argument names don't always warn](https://bugs.ruby-lang.org/issues/19973)

* 以下のようなケースで『キーが重複している警告が出ない』というバグ報告
    * 2つ目の呼び出し方だと警告が出ない

```ruby
def bar a:, b:
  a + b
end

# Warning
bar(a: 1, b: 3, a: 2)

z = { b: 123 }
# No warning
bar(a: 1, **z, a: 2)
```

* これは Ruby 3.3 で修正済み
    * バックポートされているので 3.3 未満のバージョンでも修正は反映されそう


## [[ug #20296] Complex(:sym, exception: false) generate exception with weird timing](https://bugs.ruby-lang.org/issues/20296)

* `Complex(:sym, exception: false)` が意図しないタイミングで例外を排出するというバグ報告
* 例えば以下のコードを実行したときに

```ruby
3.times { Complex(:sym, exception: false) }
puts "hi"
```

* 以下のような結果になる

```shell
$ ruby local2.rb
hi
local2.rb:1:in `Complex': can't convert Symbol into Complex (TypeError)

3.times { Complex(:sym, exception: false) }
                  ^^^^^^^^^^^^^^^^^^^^^^
        from local2.rb:1:in `block in <main>'
        from local2.rb:1:in `times'
        from local2.rb:1:in `<main>'
local2.rb:1:in `Complex': can't convert Symbol into Complex (TypeError)

3.times { Complex(:sym, exception: false) }
                  ^^^^^^^^^^^^^^^^^^^^^^
        from local2.rb:1:in `block in <main>'
        from local2.rb:1:in `times'
        from local2.rb:1:in `<main>'
local2.rb:1:in `Complex': can't convert Symbol into Complex (TypeError)

3.times { Complex(:sym, exception: false) }
                  ^^^^^^^^^^^^^^^^^^^^^^
        from local2.rb:1:in `block in <main>'
        from local2.rb:1:in `times'
        from local2.rb:1:in `<main>'
```

* 上記のように `puts "hi"` が出力されてから例外の内容が出力されている
* これなんですがそもそも `exception: false` を指定していると例外が発生しないはずなんですよね
    * > false を指定すると、変換できなかった場合、例外を発生する代わりに nil を返します。
    * [Kernel.#Complex (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/Kernel/m/Complex.html)

```ruby
# これは nil を返す
pp Complex("str", exception: false)

# これは例外が発生する
Complex("str")
```

* なので 開発版の Ruby 3.4 だと例外が発生しないようになっています

```ruby
Complex(:sym, exception: false)
# Ruby 3.3 => `Complex': can't convert Symbol into Complex (TypeError)
# Ruby 3.4 => no error
```


------------------------------------------------------------------------------------------------------------------




## [[Feature #20261] Add symbol synonyms for '' and nil for IO method line separator arguments](https://bugs.ruby-lang.org/issues/20261)

* IO 関連のメソッドで `""` と同意義の `:paragraph` と `nil` と同意義の `:slurp` を渡せるようにする提案

```ruby
pp gets(:paragraph) # gets("") と同意義
pp gets(:slurp)     # gets(nil) と同意義
```

* そもそも `""` と `nil` を渡すとどうなるのかというと

```ruby
# __END__ 以降の文字を標準入力として扱う
$stdin = DATA

# "" を渡した場合は連続する改行を行の区切りとする
pp gets("")
# => "homu\n" + "\n"

pp gets("")
# => "mami\n" + "mado\n"

__END__
homu

mami
mado
```

```ruby
# __END__ 以降の文字を標準入力として扱う
$stdin = DATA

# nil を渡した場合は行区切りなし
pp gets(nil)
# => "homu\n" + "\n" + "mami\n" + "mado\n"

__END__
homu

mami
mado
```

* はえーって感じなんですが多用する場合は読みやすいんですかねー
* PR: https://github.com/ruby/ruby/pull/9921
* 参照: [IO#gets (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/IO/i/gets.html)



## [[Misc #20279] Is the implementation of `respond_to_missing?` in BasicObject documentation correct?](https://bugs.ruby-lang.org/issues/20279)

* `BasicObject` ドキュメントのコードに書いてある `#respond_to_missing?` の実装は正しいのか、という質問
* 以下が該当のコード

```ruby
class MyObjectSystem < BasicObject
  DELEGATE = [:puts, :p]

  def method_missing(name, *args, &block)
    return super unless DELEGATE.include? name
    ::Kernel.send(name, *args, &block)
  end

  def respond_to_missing?(name, include_private = false)
    DELEGATE.include?(name) or super
  end
end
```

* 上記では `#respond_to_missing?` を定義しており `#respond_to_missing?` は `#respond_to?` から呼び出される想定だが `BasicObject` から `#respond_to?` はそもそも呼び出す事ができない
    * `BasicObject` ではそもそも `#respond_to?` が定義されていないので…

```ruby
# error: undefined method `respond_to?' for an instance of MyObjectSystem (NoMethodError)
MyObjectSystem.new.respond_to?(:foo)
```

* これはドキュメントに載っているコードが間違っており実際に `#respond_to_missing?` が意図する挙動になるようにするには `Kernel.#respond_to?` も定義しておく必要がある

```ruby
class Proxy < BasicObject
  DELEGATE = [:puts, :p]

  # #respond_to? が Kernel のメソッドを呼び出すようにしておく
  define_method(:respond_to?, ::Kernel.instance_method(:respond_to?))

  private

  def method_missing(name, *args, &block)
    return super unless DELEGATE.include? name
    ::Kernel.send(name, *args, &block)
  end

  def respond_to_missing?(name, include_private = false)
    DELEGATE.include?(name)
  end
end

proxy = Proxy.new
p proxy.respond_to?(:puts)
proxy.puts "Hello"
```


## [[Bug #20180] Inconsistent evaluation of `**{}` depending on position in array](https://bugs.ruby-lang.org/issues/20180)

* 次のように `[**{}]`  と `[a, **{}]` したときで `{}` の展開のされ方が異なるというバグ報告

```ruby
args = []; kwargs = {}
pp [*args]      # => []

# これは空の配列になる
pp [**kwargs]   # => []
# これは {} を含んだ配列になる
pp [*args, **kwargs]   # => [{}]

pp [*args] + [**kwargs] == [*args, **kwargs]   # => false
```

* これは開発版では `[a, **{}] # => [a]` となるように修正された


## [[Bug #20278] syntax error, unexpected local variable or method, expecting ')' (SyntaxError) - but I think it should report that a ',' is missing, or alternatively, that suggesting ')' is the most likely cause but not always (e. g. reword it a bit)](https://bugs.ruby-lang.org/issues/20278)

* 以下のように途中で `,` が抜けているコードを実行したときに

```ruby
class Foobar

  def foo1
    var1 = 1
    var2 = 2
    Foobar.some_method(
      var1   # <- ここの , が抜けている！
      var2,
    )
  end

  def self.some_method(a, b)
    puts a
  end

end

Foobar.new
```

* 以下のようなエラーが表示される

```
/tmp/vAanI2B/86: --> /tmp/vAanI2B/86
expected a `)` to close the argumentsexpected a newline or semicolon after the statementcannot parse the expression
   1  class Foobar
   3    def foo1
>  4      var1 = 1
>  5      var2 = 2
>  6      Foobar.some_method(
>  9      )
  10    end
  16  endSo ruby indicates that there is an issue with var2 and a ')' was expecting. But I think ruby should instead have
expected a ','. I don't know whether ruby can distinguish between this; both var1 and var2 were already defined prior, so I think in theory the ruby parser could find out that there are two separate variables, and assume that a ',' could also be missing. I don't know if this is always the case, but at the least I think in the example code I showed, ruby saying that a ')' was expected, was wrong, in my opinion.
/tmp/vAanI2B/86:8: syntax error, unexpected local variable or method, expecting ')' (SyntaxError)
      var2
      ^~~~
```

* このときに

```
# 引数を閉じるには `)` が必要ですステートメントの後に改行またはセミコロンが必要です式を解析できません
expected a `)` to close the argumentsexpected a newline or semicolon after the statementcannot parse the expression
```

* と

```
# 構文エラー、予期しないローカル変数またはメソッド、「)」が必要です (SyntaxError)
syntax error, unexpected local variable or method, expecting ')' (SyntaxError)
```

* がエラーメッセージとして適切でないという内容
* 前者は `arguments expected` や `statement cannot` のようにスペースがあるのが正しいという指摘
    * これ、全然気づかなかった‥・
* 者は `)` が原因なように読めるが実際には `,` がないことによるエラー起因なのが読みづらいという指摘
* 後者に関しては以下のように `)` だけではなくて `,` も含めるようにすればどうか、と提案されている

```
syntax error, unexpected local variable or method, expecting ')' (SyntaxError)
↓
syntax error, unexpected local variable or method, expecting ')' or ',' (SyntaxError)
```

* まあ〜ないよりはあったほうがよさそう、ってぐらいすかねえ
* `syntax_suggest` みたいになんかいい感じにエラー箇所が検知できれば…


## [[Bug #20217] void value not checked for begin/ensure/rescue](https://bugs.ruby-lang.org/issues/20217)

* 以下のように単純に `return` の結果を代入しようとするとシンタックスエラーになる

```ruby
# error: void value expression (SyntaxError)
foo = return
```

```ruby
# error: void value expression (SyntaxError)
foo = begin
        return
      end
```

* しかし次のように `begin ~ ensure ~ end` を介すとシンタックスエラーにならないというバグ報告

```ruby
# no error
foo = begin
        return
      ensure
      end
```

* これは開発版だと修正済み

```ruby
# Ruby 3.3 => no error
# Ruby 3.4 => void value expression (SyntaxError)
foo = begin
        return
      ensure
      end
```


## [[Feature #20266] New syntax to escape embed strings in Regexp literal](https://bugs.ruby-lang.org/issues/20266)

* 文字列と正規表現リテラルで展開したいときにそれが正規表現として解釈される

```ruby
foo = "[a-z]"
p /#{foo}/ #=> /[a-z]/
```

* このときに正規表現ではなくて単に文字列として埋め込む場合はエスケープする必要がある

```ruby
foo = "[a-z]"
p /#{Regexp.quote(foo)}/ #=> /\[a\-z\]/
```

* このときに `Regex.quote` を呼び出すリテラルを新しく追加する提案

```ruby
foo = "[a-z]"
p /#{=foo}/ #=> /\[a\-z\]/
```

* で以下のようなケースでエスケープする必要があり、そういう場合に有用であるとコメントされてる
    * https://bugs.ruby-lang.org/issues/20266#note-3

```ruby
hostname = "example.co.jp"
# . が正規表現として解釈されると意図しないマッチがされる可能性がある
%r{\Ahttps://#{hostname}/}.match?(callback_url)
```

* ぶっちゃけ個人的には `Regex.quote` を付ける付けないはそこまで意識てなかったんですが、意識してる人的にはあると便利なんですかねー


## [[Feature #20205] Enable `frozen_string_literal` by default](https://bugs.ruby-lang.org/issues/20205)

* `frozen_string_literal` をデフォルトで有効にするチケット
* いくつかポイントがあるんですがこの機能自体がかなり強い非互換になるので以下のような移行パスを提案している
    * Release R0: 非推奨警告を導入（非推奨警告が有効な場合のみ）
    * Release R1: 設定に関係なく非推奨警告を表示する
    * Release R2: `frozen_string_literal` をデフォルトで有効にする
    * NOTE: これらの移行パスは具体的にどういうバージョンで適用されるのかはまた別の話
* また既に非推奨警告の実装は Shopify 側で実装しているらしい
    * https://github.com/Shopify/ruby/pull/549
    * かいつまむと以下のような対応らしい
        * `#frozen_string_literal: true` または `#frozen_string_literal: false` が定義されているファイルにはなにも影響がない
        * `#frozen_string_literal` がないファイルではコンパイル時に `putstring` の変わりに `putchilledstring` が使用される
        * `putchilledstring` では文字列をマークしておき、文字列が変更されたら警告を出すようにいなっている
* 互換性に関する話としては以下のようなオプションを指定する事で互換性を保つことができる、とも書いてある
    * `RUBYOPT="--disable=frozen_string_literal"`
    * ちなみに既存で `--enable=frozen_string_literal` を指定する事ができる
* `frozen_string_literal` を有効にする利点としてパフォーマンスと意図しない変更を防ぐ目的がある
* パフォーマンスに関しては https://bugs.ruby-lang.org/issues/20205#note-4 にいくつかのライブラリのベンチマークが載っている
    * 最大で5％のパフォーマンスが改善されている
    * 逆に -6% 遅くなっているケースもある
    * 後続の検証は https://bugs.ruby-lang.org/issues/20205#note-34 になる
* 意図しない変更、は例えば以下のようなコードとかですね

```ruby
HEADER = "<html><body>"

def generate
  output = HEADER # no `.dup`
  output << "<p>test</p>" # HEADER の値が変わってしまう
  # ...
end
```

* 他の論点としては `--enable-frozen-string-literal` を使ったほうがいいのではないか、みたいな議論もされている
* 最終的にはこの対応自体は matz が同意しているので次の Ruby のバージョンから何かしらの対応が入りそう
    * https://bugs.ruby-lang.org/issues/20205#note-35
* いつになるかは置いといてまた Ruby 3.0 のキーワード引数と同じぐらいの対応が必要になってきそうですねー



--------------------------------------------------------------------------------------


## [[Feature #19117] Include the method owner in backtraces, not just the method name](https://bugs.ruby-lang.org/issues/19117)

* エラーとバックトレースの内容のメソッド名に『どのクラスで定義されているのか』の情報を含めるようにする提案
* 以下のコードを実行したときに

```ruby
module Foo
  class Bar
    def inspect
      1 + '1'
    end
  end
end

p Foo::Bar.new
```

* 以下のようなエラーが出力されるが

```
/tmp/foo.rb:4:in `+': String can't be coerced into Integer (TypeError)
	from /tmp/foo.rb:4:in `inspect'
	from /tmp/foo.rb:9:in `p'
	from /tmp/foo.rb:9:in `<main>'
```

* 以下のように『どこで定義されているのか』を追加する提案

```
/tmp/foo.rb:4:in `Integer#+': String can't be coerced into Integer (TypeError)
	from /tmp/foo.rb:4:in `Foo::Bar#inspect'
	from /tmp/foo.rb:9:in `Kernel#p'
	from /tmp/foo.rb:9:in `<main>'
```

* 普通に便利そう
* 懸念点としては `#inspect` をそのまま利用すると Rails では以下のような出力されれる可能性があるとコメントされている
    * https://bugs.ruby-lang.org/issues/19117#note-1

```
app/models/organization.rb:458:in `Organization(id: integer, name: string, created_at: datetime, updated_at: datetime, ....and so on, 35 fields in total...)#inspect`
```

* 他にも特異クラスや無名クラスの場合にどうするのか、みたいな話もでていますね
    * https://bugs.ruby-lang.org/issues/19117#note-5
* 他も以下のうような話とか
    * 定義されているクラスなのか、呼び出したクラスなのか
    * https://bugs.ruby-lang.org/issues/19117#note-16

```ruby
class Foo
  def inspect
    raise "hmm"
  end
end

class Bar < Foo
end

Bar.new.inspect
#/path/to/foo.rb:3:in `Foo#inspect': hmm (RuntimeError)
#or
#/path/to/foo.rb:3:in `Bar#inspect': hmm (RuntimeError)
```

* チケット自体は1年以上前につくられているんですが Ruy 3.2 のリリース直前に議論されていたぽいので暫く止まってたみたいですね
* いまは Ruby 3.4 に向けて開発しているみたいです
    * 概ね肯定ぽいけどパフォーマンスどうなのか、みたいな議論がされている
    * あとバッククオートについても言及されている
* 以下みたいにやや冗長なケースもありつつまあ普通に便利そうすねー

```
#before
from /opt/ruby/3.1/lib/ruby/gems/3.1.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/abstract/database_statements.rb:531:in 'with_multi_statements'

#after
from /opt/ruby/3.1/lib/ruby/gems/3.1.0/gems/activerecord-7.0.3/lib/active_record/connection_adapters/abstract/database_statements.rb:531:in 'ActiveRecord::ConnectionAdapters::DatabaseStatements#with_multi_statements'
```


## [[Feature #16495] Inconsistent quotes in error messages](https://bugs.ruby-lang.org/issues/16495)

* Ruby のエラーメッセージは以下のようにバッククオートとシングルクオートが使われている

```
-e:1:in `<main>': undefined local variable or method `foo' for main:Object (NameError)
```

* これを同じクオートにしたいという要望
* なぜこうなっているのかといういわゆる歴史的経緯って感じなんですかね？
    * https://bugs.ruby-lang.org/issues/16495#note-7
* これを変えることにより影響がないか危惧しているぽいすねー
    * まあエラーメッセージからいい感じにパースしているツールはめっちゃ影響ありそう
* チケット自体は4年前でかなり長期的に議論されているんですが matz 的には互換性に問題がなければシングルクオートに統一する事に肯定的みたいですねー
    * https://bugs.ruby-lang.org/issues/16495#note-28
* 個人的には同じ記号の方が扱いやすいので統一はされてほしいところ


## [[Bug #20188] `Module#const_source_location` returns wrong information when real constant was defined but autoload is still ongoing](https://bugs.ruby-lang.org/issues/20188)

* `autoload` 中に `Module#const_source_location` の値が正しく取得できないというバグ報告

```ruby
# /tmp/autoload.rb
File.write("/tmp/const.rb", <<~RUBY)
module Const
  LOCATION = Object.const_source_location(:Const)
end
RUBY

autoload :Const, "/tmp/const"

p Const::LOCATION
# 期待する値 => ["/tmp/const.rb", 8]
# 実際の値   => ["/tmp/autoload.rb", 8]

# これは意図する位置を返す
p Object.const_source_location(:Const)
# => ["/tmp/const.rb", 1]
```

* `autoload` のスレッドセーフを保つために `autoload` が完了するまでは他のスレッドに値を公開されないようにするためぽい？ってコメントがされています
    * https://bugs.ruby-lang.org/issues/20188#note-1
* その延長戦で `autoload` 中に例外が発生した場合は『そこで定義した定数が定義されない』みたいな話もあるみたいですね

```ruby
# /tmp/foo.rb
File.write('/tmp/bar.rb', 'Bar = 1; raise')
autoload :Bar, '/tmp/bar'

# ここで Bar を呼び出しており autoload 経由で `/tmp/bar` が読み込まれる
# このときに内部で例外が発生する
Bar rescue nil

# 例外が発生すると Bar が定義されていない状態として扱われる
p Object.const_source_location(:Bar) # ["/tmp/foo.rb", 3]
p Object.autoload?(:Bar) # "/tmp/bar"

# なので再度 Bar を呼び出すと autoload が発火し、また例外が発生する
p Bar # raises
```

* そこから複数のスレッドから `autoload` （や `require` ）が呼び出された時にどうするのか、みたいな話に発展しています
    * 詳しくは [Misc #20232: Document Kernel#require and Module#autoload concurrency guarantees](https://bugs.ruby-lang.org/issues/20232) を参照
* ザッと読んだんですがスレッド周りなど思ったよりも話が深い…


## [[Bug #19918] Should `a[&b]=c` be syntax valid?](https://bugs.ruby-lang.org/issues/19918)

* 以下のコードは現状の Ruby だと有効なコードになる

```ruby
a[&b]=c
a[&b]+=c
a[&b]&&=c
a[&b]||=c
```

* `a[&b]=c` は `a.[](c, &b)` みたいなコードとして解釈される

```ruby
class X
  def []=(*args, &block)
    pp args         # => [10]
    pp block.call   # => 42
  end
end

a = X.new
b = proc { 42 }
c = 10
a[&b] = c
```

* Prism だとこれがシンタックスエラーになるがこの構文が意図的に動作しているのか質問しているチケット
* 少なくともテストはあるみたいなので意図的ではあるみたい
    * https://bugs.ruby-lang.org/issues/19918#note-4
* matz 的には `a[&b]` は許容して `a[&b] = c` は禁止にしたいみたいですね
    * https://bugs.ruby-lang.org/issues/19918#note-5


## [[Bug #20094] Inline while loop behavior changed unexpectedly in 3.3.0](https://bugs.ruby-lang.org/issues/20094)

* Ruby 3.3.0 で後置 `while` の挙動が変わっているというバグ報告

```ruby
(p 1) while false
# Ruby 3.2 => nothing
# Ruby 3.3 => 1

(p 1; p 2) while false
# Ruby 3.2 => nothing
# Ruby 3.3 => 1 2
```

* この問題は既に開発版の Ruby では修正済み
* 多分バックポートされているので多分 Ruby 3.3.1 では修正が取り込まれるはず
* ちなみに `while` の左辺を `begin end` にすることで意図的に `do ~ while` のような処理にすることは可能

```ruby
begin
  p 1
end while false
# Ruby 3.2 => 1
# Ruby 3.3 => 1
```


## [[Feature #20160] rescue keyword for case expressions](https://bugs.ruby-lang.org/issues/20160)

* `case ~ when` で `rescue` 節も含めるようにしたいという提案
* 例えば以下のよう `case ~ when` があるときに

```ruby
case (parsed = parse(input))
when Integer then handle_int(parsed)
when Float then handle_float(parsed)
end
```

* `parse` の例外をキャッチしたい場合は以下のように記述する必要がある

```ruby
begin
  case (parsed = parse(input))
  when Integer then handle_int(parsed)
  when Float then handle_float(parsed)
    # ...
  end
rescue ParseError
  # ...
end
```

* これを以下のよう記述したいという旨になる

```ruby
case (parsed = parse(input))
when Integer then handle_int(parsed)
when Float then handle_float(parsed)
rescue ParseError
  # ...
rescue ArgumentError
  # ...
else
  # ... fallthrough for all rescue and when cases
ensure
  # ... called always
end
```

* 他にも以下のようなコードも例としてあげられています。おもしろい

```ruby
parser = Parser.new(io)

loop do
  case parser.parse # blocks for reading io in chunks
  rescue StandardError => e
    if parser.can_recover?(e)
      # tolerate failure, ignore
      next
    else
      emit_fail(e)
      break
    end
  when :integer
    emit_integer(parser.last)
  when :float
     emit_float(parser.last)
  when :done
     # e.g EOF reached, IO closed, YAML --- end of doc, XML top-level closed, whatever makes sense
     emit_done
     break
  else
    parser.rollback # e.g rewinds io, we may not have enough data
  ensure
    parser.checkpoint # e.g saves io position for rollback
  end
end
```

* それに対してパターンマッチで解決するようなコメントもされていますね。これもおもしろい
    * https://bugs.ruby-lang.org/issues/20160#note-3

```ruby
def parse(input)
  # parsing logic
rescue StandardError => e
  [:error, e]
end


case parse(input)
in Integer => parsed_int
  handle_int(parsed_int)
in Float => parsed_float
  handle_float(parsed_float)
in :error, ParseError => error
  # handle ParseError
in :error, ArgumentError => error
  # handle ArgumentError
else
  # all other cases — note that there is no assignment here
  # but most parsing should probably be exhaustive
end
```

* 最終的には matz が『処理すべき例外の発生源について混乱する可能性がある』『（コメントに提示されていた）以下のコードの方が直感的でわかりやすい』ということで Reject されている

```ruby
def parse(input)
  # parsing logic
rescue StandardError => e
  [:error, e]
end


case parse(input)
in Integer => parsed_int
  handle_int(parsed_int)
in Float => parsed_float
  handle_float(parsed_float)
in :error, ParseError => error
  # handle ParseError
in :error, ArgumentError => error
  # handle ArgumentError
else
  # all other cases — note that there is no assignment here
  # but most parsing should probably be exhaustive
end
```


## [[Bug #20253] `Proc.dup` and `Proc#clone` don't preserve finalizers](https://bugs.ruby-lang.org/issues/20253)

* `ObjectSpace.define_finalizer` に渡したオブジェクトを `#dup/clone` した場合はその複製したオブジェクトごとに `finalizer` が呼ばれる
    * `ObjectSpace.define_finalizer` は指定したオブジェクトが解放されるときに実行される処理を仕込むためのメソッド
    * [ObjectSpace.#define_finalizer (Ruby 3.3 リファレンスマニュアル)](https://docs.ruby-lang.org/ja/latest/method/ObjectSpace/m/define_finalizer.html)

```ruby
def fin(sym)
  # obj が解放されるときにこのブロックが呼ばれる
  ->(obj) { p "#{sym}: #{obj}" }
end

obj = Object.new
ObjectSpace.define_finalizer(obj, fin(:obj))
obj.dup
obj.clone
__END__
output:
"obj: 60"
"obj: 80"
"obj: 100"
```

* これが `obj` が `Proc` の場合は呼ばれないというバグ報告

```ruby
def fin(sym)
  # obj が解放されるときにこのブロックが呼ばれる
  ->(obj) { p "#{sym}: #{obj}" }
end

proc = Proc.new { }
ObjectSpace.define_finalizer(proc, fin(:proc))
# ここでコピーしたオブジェクトの finalizer は呼ばれない
proc.dup
proc.clone
__END__
"proc: 60"
```

* 他にも `Proc#dup` した場合はインスタンス変数がコピーされない、みたいな挙動もあるみたいですね

```ruby
def ivar_dup(obj)
  obj.instance_variable_set(:@foo, 1)
  p [:dup, obj.dup.instance_variable_get(:@foo)]
  p [:clone, obj.clone.instance_variable_get(:@foo)]
end

ivar_dup(Object.new)
ivar_dup(Proc.new { })
__END__
output:
[:dup, 1]
[:clone, 1]
[:dup, nil]
[:clone, 1]
```

* これらの問題は開発版の Ruby では修正済み



------------------------------------------------------------




## [[Bug #20043] `defined?` checks for method existence but only sometimes](https://bugs.ruby-lang.org/issues/20043)

* `defined?` はメソッドの存在をチェックするが、たまにしかチェックしないというバグ報告
* 例えば以下のようなコードであれば `expression` を返す

```ruby
p defined? []     # => "expression"
p defined? [*a]   # => "expression"
```

```ruby
p(defined? [])
p(defined? [*a])
```

* しかし、次のように未定義？の値を渡すと `nil` が返ってくるケースもある

```ruby
def a; end

# これはなにかしら意図する値が返ってくる
p defined?(a)     # => "method"
p defined?([a])   # => "expression"

# これは nil が返ってくる
p defined?(b)     # => nil
p defined?([b])   # => nil
```

* またこれは通常のメソッドでも同じような挙動になる

```ruby
p defined?(itself)       # => "method"
p defined?(itself(a))    # => nil
p defined?(itself(*a))   # => "method"
```

* また `[]` は中身までチェックするんですが `{}` は中身までチェックしないみたいですね

```ruby
p defined?([[[a]]])      # => nil
p defined?({ a => a })   # => "expression"
```

* `defined?(foo(*a))` が `"method"` を返すようになったのは 1.9 からのバグぽいらしいですね？
    * https://bugs.ruby-lang.org/issues/20043#note-5
* いまは以下のような挙動になる PR が出されてます
    * https://github.com/ruby/ruby/pull/9500
    * 基本的にメソッドが定義されていれば `nil` 以外、定義されていなければ `nil` みたいな挙動ですかね？

```ruby
defined?([*a])         # => nil
defined?(itself(*a))   # => nil
defined?([*itself]     # => "expression"
defined?({a => a})     # => nil
defined?({itself => itself})   # => "expression"
```




## [[Bug #20085] Fiber.new{ }.resume causes Segmentation fault for Ruby 3.3.0 on aarch64-linux](https://bugs.ruby-lang.org/issues/20085)

* aarch64-linux 環境で Ruby 3.3 の `Fiber.new{ }.resume` が segv するというバグ報告
* 厳密に言うと『PAC をサポートした aarch64』で壊れていたみたいですね
    * https://bugs.ruby-lang.org/issues/20085#note-10
    * [Arm アーキテクチャ v8.3-A: ポインタ認証コードの解説](https://zenn.dev/hidenori3/articles/c5e8ce75608730)
* この問題は既に修正済みで Ruby 3.3.1 にバックポートされる予定
* ちなみに以下のようにビルドオプションを調整する事で回避することが可能

```shell
./configure ASFLAGS=-mbranch-protection=pac-ret
```


## [[Bug #20095] Regex lookahead behaving strangely in 3.3.0](https://bugs.ruby-lang.org/issues/20095)

* Ruby 3.3.0 で正規表現の先読みがおかしいというバグ報告
* 以下のコードを実行すると Ruby 3.3 と 3.2 で挙動が異なります

```ruby
p "xxx" =~ /(?=.*x)x(?=banana)/
# Ruby 3.2.2 => nil
# Ruby 3.3.0 => 2
```


## [[Bug #20083] String#match? behaving inconsistently with Ruby 3.3.0](https://bugs.ruby-lang.org/issues/20083)

* 同様に Ruby 3.3.0 で正規表現がおかしいというバグ報告
* 以下のコードは Ruby 3.2.2 では全て `true` になるが Ruby 3.3.0 の場合は `false` になるケースが存在している

```ruby
# /i のときに再現する
pattern = /([\s]*ABC)$/i # or /(\s*ABC)/i

# Ruby 3.3.0 の実行結果
p "1ABC".match?(pattern) # => true
p "12ABC".match?(pattern) # => true
p "123ABC".match?(pattern) # => true
p "1231ABC".match?(pattern) # => true
p "12312ABC".match?(pattern) # => false
p "123123ABC".match?(pattern) # => false
p "1231231ABC".match?(pattern) # => true
p "12312312ABC".match?(pattern) # => true
p "123123123ABC".match?(pattern) # => false
p "1231231231ABC".match?(pattern) # => false
p "12312312312ABC".match?(pattern) # => true
p "123123123123ABC".match?(pattern) # => true
p "1231231231231ABC".match?(pattern) # => false
```

* バグの原因は `/\s*ABC/i` が内部では `/(?>\s*)ABC/` に最適されるんですがこのときにアトミックグループにバグがあるらしくて、結果的におかしな結果になるらしいです
    * https://bugs.ruby-lang.org/issues/20083#note-5
* また `/\s*ABC/` のように `i` がない場合は `/(?:(?!A)\s)*ABC/` に最適化され、この時はアトミックグループにはならないので問題ないらしい
* この問題は開発版の Ruby では既に修正済み
    * [Fix [Bug #20083]: correct a cache point size for atomic groups by makenowjust · Pull Request #9367 · ruby/ruby](https://github.com/ruby/ruby/pull/9367)




## [[Feature #20080] Introduce #bounds method on Range](https://bugs.ruby-lang.org/issues/20080)

* `Range#begin, end` を返す `Range#bounds` メソッドを追加する提案

```ruby
# [begin, end] の配列を返す
first, last = (1..300).bounds # => [1, 300]
first, last = (300..1).bounds # => [300, 1]
first, last = (..300).bounds # => [nil, 300]
first, last = (1..).bounds # => [1, nil]
```

* また `Range#exclude_end?` が `true` の場合はその情報が第三要素で受け取る事ができる
    * これを利用してシリアライズ化が簡単にできるようになる

```ruby
# ... の場合は第三要素に true が渡される
a = (1..2).bounds  #=> [1,2]
b = (1...2).bounds #=> [1,2,true]

# これを利用すると bounds の結果から元の Range を簡単に復元する事ができる
Range.new(*a)      #=> 1..2
Range.new(*b)      #=> 1...2
```

* この `Range#exclude_end?` 値を含めるか含めないかは `Range#bounds` の引数で制御することができる

```ruby
# true を渡すと Range#exclude_end? の結果に変わらずに含める
(1..2).bounds(true)  #=> [1,2,false]
(1...2).bounds(true)  #=> [1,2,true]

# false を渡すと Range#exclude_end? の結果に変わらずに含めない
(1..2).bounds(false)  #=> [1,2]
(1...2).bounds(false)  #=> [1,2]
```

* このチケットの背景は [Feature #20027: Add Range Deconstruction](https://bugs.ruby-lang.org/issues/20027) で `Range` を分割代入したい、っていう要望からの派生ですね
* 上記のチケットだと `Range` を直接分割代入するのは Reject されたんですが、その代わりにメソッドを追加する案があったのでそれの派生になります
* `Range#minmax` と似ているんですが `#minmax` の場合は `begin > end` の場合に `nil` を返したりするのでちょっとだけ挙動が異なります

```ruby
(1..42).minmax #=> [1, 42]
(42..1).minmax #=> [nil, nil]
```

* まあ普通に便利そうな感じはしますねー


## [[Bug #20084] Breaking change with Regexp.new on 3.3.0](https://bugs.ruby-lang.org/issues/20084)

* `Range.new` の引数が Ruby 3.3 から 1〜2個しか渡せなくなったというバグ報告

```ruby
Regexp.new 'abc', 'i', 'n'
# Ruby 3.2 => no error
# Ruby 3.3 => error: wrong number of arguments (given 3, expected 1..2) (ArgumentError)
```

* これは期待する挙動で [Bug #18797: Third argument to Regexp.new is a bit broken](https://bugs.ruby-lang.org/issues/18797) のチケットで不要だと判断されて削除対応がされました
* また、この変更は非互換になるので Ruby 3.2 では `-W` で警告がでるようになっていました

```ruby
Regexp.new("this is regexp", Regexp::IGNORECASE, "n")
# Ruby 3.1 => no warning
# Ruby 3.2 => warning: 3rd argument to Regexp.new is deprecated and will be removed in Ruby 3.3; use 2nd argument instead
# Ruby 3.3 => error: wrong number of arguments (given 3, expected 1..2) (ArgumentError)
```

* 参照: https://docs.ruby-lang.org/ja/3.2/class/Regexp.html#S_COMPILE



## [[Feature #19370] Anonymous parameters for blocks?](https://bugs.ruby-lang.org/issues/19370)

* 以下のようにブロックの引数で匿名引数を受け取り、それをフォワードしたい場合にエラーになるが、実装可能であればサポートを追加してほしい、というチケット  

```ruby
# data in form [request method, URL, params]:
[
  [:get, 'https://google.com', {q: 'Ruby'}, {'User-Argent': 'Google-Chrome'}],
  [:post, 'https://gist.github.com', 'body'],
  # ...
].each { |method, *| request(method.to_s.upcase, *) }
```

* と、いうのが元々のこのチケットの趣旨だったのですが、以下のようにメソッドの匿名引数をブロック内で別のメソッドにフォワードした場合に混乱する可能性があるという話にシフトしました

```ruby
def test(*)
  # ...

  # p(*) の * は実際には test(*) で受け取った引数がフォワードされる
  proc { |*| p(*) }.call(1)
end

test(2) #=> prints 2 (method's anonymous arguments, not proc's)
```

* これが意図しない挙動につながるのでこのチケットでは以下のように対応する事になりました
    * https://bugs.ruby-lang.org/issues/19370#note-8

```ruby
def m(*)
  # ブロックの引数で * を受け取り、ブロックの中で * を参照する場合はシンタックスエラーにする
  ->(*) { p(*) }    # SyntaxError
  ->(x, *) { p(*) } # SyntaxError

  # ブロックの引数で * を受け取らない場合はブロックの中で * が参照できる
  ->(x) { p(*) }    #=> 1
  proc {|x| p(*) }  #=> 1
end

m(1).call(2)
```

* で、Ruby 3.3.0 ではこの対応を含んでリリースされたんですがこの挙動にバグがあり **許容する想定の下2つのコードもエラーになるバグ** が含まれてしまっています

```ruby
def m(*)
  # この2つもエラーになっちゃう
  ->(x) { p(*) }    #=> SyntaxError
  proc {|x| p(*) }  #=> SyntaxError

  # こういうのも
  -> { p(*) }    #=> SyntaxError
end

m(1).call(2)
```

* この問題は [Bug #20090: Anonymous arguments are now syntax errors in unambiguous cases](https://bugs.ruby-lang.org/issues/20090) などで報告されているんですが既に開発版では対応済みです
* クリティカルなバグだと思うのでそのうち Ruby 3.3.1 が出ると思うんですが、対応前にアップデートするのは難しそうですねえ…
* 事前に（自分で）動作確認できていれば防げたと思うのでちょっと悔しい
    * このチケットの経緯詳しく確認してなかったんだよなあ…
    * これを対応したのがリリース2日前とかっていうのもちょっとね…





[2024-01-09 18:03]

